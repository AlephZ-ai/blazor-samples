{
  "version": 3,
  "sources": ["../../scripts/app.ts"],
  "sourcesContent": ["\uFEFF//import { MediaRecorder, register } from 'extendable-media-recorder';\r\n//import { connect } from 'extendable-media-recorder-wav-encoder';\r\n//await register(await connect());\r\nlet recorder: MediaRecorder | null;\r\nexport interface BrowserMediaDevice {\r\n    DeviceId: string;\r\n    Label: string;\r\n    Kind: string;\r\n    GroupId: string;\r\n}\r\n\r\nexport function startMediaSource(page: DotNet.DotNetObject) {\r\n    const audioElement = document.getElementById('audioElement') as HTMLAudioElement;\r\n    const mediaSource = new MediaSource();\r\n    mediaSource.addEventListener('sourceopen', () => {\r\n        const sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg');\r\n        readBufferChunks(page, sourceBuffer);\r\n        audioElement.play();\r\n    }, { once: true });\r\n\r\n    audioElement.src = URL.createObjectURL(mediaSource);\r\n    window.onmouseup = () => {\r\n        page.invokeMethod(\"EndSpeaking\");\r\n        stopRecording()\r\n    }\r\n}\r\n\r\nasync function readBufferChunks(page: DotNet.DotNetObject, sourceBuffer: SourceBuffer) {\r\n    const chunk: Uint8Array | null = await page.invokeMethodAsync(\"Pop\");\r\n    if (!chunk) return;\r\n    sourceBuffer.appendBuffer(chunk);\r\n    sourceBuffer.addEventListener('updateend', () => readBufferChunks(page, sourceBuffer), { once: true });\r\n}\r\n\r\nexport async function getAudioInputDevices(): Promise<BrowserMediaDevice[]> {\r\n    try {\r\n        const devices: MediaDeviceInfo[] = await navigator.mediaDevices.enumerateDevices();\r\n        return devices.filter((device: MediaDeviceInfo) => device.kind === 'audioinput').map((device: MediaDeviceInfo) => ({\r\n            DeviceId: device.deviceId,\r\n            Label: device.label || 'Unknown Audio Device',\r\n            Kind: device.kind,\r\n            GroupId: device.groupId\r\n        }));\r\n    } catch (error: unknown) {\r\n        console.error('Error fetching audio input devices', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function requestMicrophonePermission(): Promise<boolean> {\r\n    try {\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        return true;\r\n    } catch (error: unknown) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function getSupportedMimeType(): string | null {\r\n    // audio/webm=chrome/edge/firefox, audio/mp4=safari\r\n    //const types: string[] = ['audio/wav'];\r\n    const types: string[] = ['audio/webm', 'audio/mp4'];\r\n    for (const type of types) {\r\n        if (MediaRecorder.isTypeSupported(type)) {\r\n            return type;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport async function startRecording(page: DotNet.DotNetObject, deviceId: string): Promise<string | null> {\r\n    let mimeType: string | null = getSupportedMimeType();\r\n    if (mimeType) {\r\n        const constraints: MediaStreamConstraints = { audio: { deviceId: deviceId } };\r\n        const options: MediaRecorderOptions = { mimeType: mimeType };\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n        stopRecording();\r\n        recorder = new MediaRecorder(stream, options);\r\n        mimeType = recorder.mimeType;\r\n        let stopped: boolean = false;\r\n        recorder.ondataavailable = async (e: BlobEvent) => {\r\n            const data: ArrayBuffer = await e.data.arrayBuffer();\r\n            const uint8Array: Uint8Array = new Uint8Array(data);\r\n            await page.invokeMethodAsync(\"DataAvailable\", uint8Array, mimeType);\r\n            if (stopped) {\r\n                await page.invokeMethodAsync(\"RecordingStopped\");\r\n            }\r\n        };\r\n\r\n        recorder.onstop = () => {\r\n            stopped = true;\r\n        };\r\n\r\n        recorder.start(500);\r\n    } else {\r\n        console.error('No supported audio formats found');\r\n    }\r\n\r\n    return mimeType;\r\n}\r\n\r\nexport function stopRecording(): void {\r\n    if (recorder) {\r\n        recorder.stop();\r\n        recorder.stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        recorder = null;\r\n    }\r\n}\r\n"],
  "mappings": ";AAGA,IAAI;AAQG,SAAS,iBAAiB,MAA2B;AACxD,QAAM,eAAe,SAAS,eAAe,cAAc;AAC3D,QAAM,cAAc,IAAI,YAAY;AACpC,cAAY,iBAAiB,cAAc,MAAM;AAC7C,UAAM,eAAe,YAAY,gBAAgB,YAAY;AAC7D,qBAAiB,MAAM,YAAY;AACnC,iBAAa,KAAK;AAAA,EACtB,GAAG,EAAE,MAAM,KAAK,CAAC;AAEjB,eAAa,MAAM,IAAI,gBAAgB,WAAW;AAClD,SAAO,YAAY,MAAM;AACrB,SAAK,aAAa,aAAa;AAC/B,kBAAc;AAAA,EAClB;AACJ;AAEA,eAAe,iBAAiB,MAA2B,cAA4B;AACnF,QAAM,QAA2B,MAAM,KAAK,kBAAkB,KAAK;AACnE,MAAI,CAAC;AAAO;AACZ,eAAa,aAAa,KAAK;AAC/B,eAAa,iBAAiB,aAAa,MAAM,iBAAiB,MAAM,YAAY,GAAG,EAAE,MAAM,KAAK,CAAC;AACzG;AAEA,eAAsB,uBAAsD;AACxE,MAAI;AACA,UAAM,UAA6B,MAAM,UAAU,aAAa,iBAAiB;AACjF,WAAO,QAAQ,OAAO,CAAC,WAA4B,OAAO,SAAS,YAAY,EAAE,IAAI,CAAC,YAA6B;AAAA,MAC/G,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO,SAAS;AAAA,MACvB,MAAM,OAAO;AAAA,MACb,SAAS,OAAO;AAAA,IACpB,EAAE;AAAA,EACN,SAAS,OAAgB;AACrB,YAAQ,MAAM,sCAAsC,KAAK;AACzD,WAAO,CAAC;AAAA,EACZ;AACJ;AAEA,eAAsB,8BAAgD;AAClE,MAAI;AACA,UAAM,SAAsB,MAAM,UAAU,aAAa,aAAa,EAAE,OAAO,KAAK,CAAC;AACrF,WAAO,UAAU,EAAE,QAAQ,CAAC,UAA4B,MAAM,KAAK,CAAC;AACpE,WAAO;AAAA,EACX,SAAS,OAAgB;AACrB,WAAO;AAAA,EACX;AACJ;AAEO,SAAS,uBAAsC;AAGlD,QAAM,QAAkB,CAAC,cAAc,WAAW;AAClD,aAAW,QAAQ,OAAO;AACtB,QAAI,cAAc,gBAAgB,IAAI,GAAG;AACrC,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,SAAO;AACX;AAEA,eAAsB,eAAe,MAA2B,UAA0C;AACtG,MAAI,WAA0B,qBAAqB;AACnD,MAAI,UAAU;AACV,UAAM,cAAsC,EAAE,OAAO,EAAE,SAAmB,EAAE;AAC5E,UAAM,UAAgC,EAAE,SAAmB;AAC3D,UAAM,SAAsB,MAAM,UAAU,aAAa,aAAa,WAAW;AACjF,kBAAc;AACd,eAAW,IAAI,cAAc,QAAQ,OAAO;AAC5C,eAAW,SAAS;AACpB,QAAI,UAAmB;AACvB,aAAS,kBAAkB,OAAO,MAAiB;AAC/C,YAAM,OAAoB,MAAM,EAAE,KAAK,YAAY;AACnD,YAAM,aAAyB,IAAI,WAAW,IAAI;AAClD,YAAM,KAAK,kBAAkB,iBAAiB,YAAY,QAAQ;AAClE,UAAI,SAAS;AACT,cAAM,KAAK,kBAAkB,kBAAkB;AAAA,MACnD;AAAA,IACJ;AAEA,aAAS,SAAS,MAAM;AACpB,gBAAU;AAAA,IACd;AAEA,aAAS,MAAM,GAAG;AAAA,EACtB,OAAO;AACH,YAAQ,MAAM,kCAAkC;AAAA,EACpD;AAEA,SAAO;AACX;AAEO,SAAS,gBAAsB;AAClC,MAAI,UAAU;AACV,aAAS,KAAK;AACd,aAAS,OAAO,UAAU,EAAE,QAAQ,CAAC,UAA4B,MAAM,KAAK,CAAC;AAC7E,eAAW;AAAA,EACf;AACJ;",
  "names": []
}
