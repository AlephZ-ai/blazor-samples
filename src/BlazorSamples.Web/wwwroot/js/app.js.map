{
  "version": 3,
  "sources": ["../../node_modules/fast-unique-numbers/build/es5/bundle.js", "../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js", "../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js", "../../node_modules/@babel/runtime/helpers/iterableToArray.js", "../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js", "../../node_modules/@babel/runtime/helpers/nonIterableSpread.js", "../../node_modules/@babel/runtime/helpers/toConsumableArray.js", "../../node_modules/dashify/index.js", "../../node_modules/indefinite-article/indefinite-article.js", "../../node_modules/compilerr/build/es5/bundle.js", "../../node_modules/@babel/runtime/helpers/arrayWithHoles.js", "../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js", "../../node_modules/@babel/runtime/helpers/nonIterableRest.js", "../../node_modules/@babel/runtime/helpers/slicedToArray.js", "../../node_modules/@babel/runtime/helpers/classCallCheck.js", "../../node_modules/@babel/runtime/helpers/typeof.js", "../../node_modules/@babel/runtime/helpers/toPrimitive.js", "../../node_modules/@babel/runtime/helpers/toPropertyKey.js", "../../node_modules/@babel/runtime/helpers/createClass.js", "../../node_modules/automation-events/build/es5/bundle.js", "../../node_modules/multi-buffer-data-view/build/es5/bundle.js", "../../node_modules/broker-factory/src/module.ts", "../../node_modules/broker-factory/src/guards/message-port.ts", "../../node_modules/broker-factory/src/helpers/port-map.ts", "../../node_modules/broker-factory/src/helpers/extend-broker-implementation.ts", "../../node_modules/media-encoder-host-broker/src/module.ts", "../../node_modules/media-encoder-host/src/worker/worker.ts", "../../node_modules/media-encoder-host/src/module.ts", "../../node_modules/extendable-media-recorder/src/factories/blob-event-factory.ts", "../../node_modules/extendable-media-recorder/src/factories/decode-web-m-chunk.ts", "../../node_modules/extendable-media-recorder/src/factories/event-target-constructor.ts", "../../node_modules/extendable-media-recorder/src/factories/event-target-factory.ts", "../../node_modules/extendable-media-recorder/src/factories/invalid-modification-error.ts", "../../node_modules/extendable-media-recorder/src/factories/invalid-state-error.ts", "../../node_modules/extendable-media-recorder/src/factories/media-recorder-constructor.ts", "../../node_modules/extendable-media-recorder/src/factories/native-blob-event-constructor.ts", "../../node_modules/extendable-media-recorder/src/factories/native-media-recorder-constructor.ts", "../../node_modules/extendable-media-recorder/src/factories/native-media-recorder-factory.ts", "../../node_modules/extendable-media-recorder/src/factories/not-supported-error.ts", "../../node_modules/extendable-media-recorder/src/factories/read-element-content.ts", "../../node_modules/extendable-media-recorder/src/factories/read-element-type.ts", "../../node_modules/extendable-media-recorder/src/factories/read-variable-size-integer.ts", "../../node_modules/recorder-audio-worklet/src/module.ts", "../../node_modules/rxjs-interop/source/symbols.ts", "../../node_modules/rxjs-interop/source/patch.ts", "../../node_modules/rxjs-interop/source/to-observer.ts", "../../node_modules/subscribable-things/src/factories/animation-frame.ts", "../../node_modules/subscribable-things/src/factories/attribute.ts", "../../node_modules/subscribable-things/src/factories/geolocation.ts", "../../node_modules/subscribable-things/src/factories/intersections.ts", "../../node_modules/subscribable-things/src/factories/map-subscribable-thing.ts", "../../node_modules/subscribable-things/src/factories/media-devices.ts", "../../node_modules/subscribable-things/src/factories/media-query-match.ts", "../../node_modules/subscribable-things/src/factories/metrics.ts", "../../node_modules/subscribable-things/src/factories/midi-inputs.ts", "../../node_modules/subscribable-things/src/factories/midi-outputs.ts", "../../node_modules/subscribable-things/src/factories/mutations.ts", "../../node_modules/subscribable-things/src/factories/on.ts", "../../node_modules/subscribable-things/src/factories/online.ts", "../../node_modules/subscribable-things/src/factories/permission-state.ts", "../../node_modules/subscribable-things/src/factories/prepend-subscribable-thing.ts", "../../node_modules/subscribable-things/src/factories/reports.ts", "../../node_modules/subscribable-things/src/factories/resizes.ts", "../../node_modules/subscribable-things/src/factories/unhandled-rejection.ts", "../../node_modules/subscribable-things/src/factories/video-frame.ts", "../../node_modules/subscribable-things/src/factories/wake-lock.ts", "../../node_modules/subscribable-things/src/factories/window.ts", "../../node_modules/subscribable-things/src/factories/wrap-subscribe-function.ts", "../../node_modules/subscribable-things/src/functions/emit-not-supported-error.ts", "../../node_modules/subscribable-things/src/module.ts", "../../node_modules/worker-factory/src/helpers/error-renderers.ts", "../../node_modules/worker-factory/src/helpers/extend-worker-implementation.ts", "../../node_modules/recorder-audio-worklet/src/factories/add-recorder-audio-worklet-module.ts", "../../node_modules/recorder-audio-worklet/src/factories/listener.ts", "../../node_modules/recorder-audio-worklet/src/factories/post-message-factory.ts", "../../node_modules/recorder-audio-worklet/src/factories/recorder-audio-worklet-node-factory.ts", "../../node_modules/recorder-audio-worklet/src/functions/validate-state.ts", "../../node_modules/recorder-audio-worklet/src/worklet/worklet.ts", "../../node_modules/standardized-audio-context/src/module.ts", "../../node_modules/standardized-audio-context/src/factories/abort-error.ts", "../../node_modules/standardized-audio-context/src/factories/add-active-input-connection-to-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/add-audio-node-connections.ts", "../../node_modules/standardized-audio-context/src/factories/add-audio-param-connections.ts", "../../node_modules/standardized-audio-context/src/globals.ts", "../../node_modules/standardized-audio-context/src/helpers/is-constructible.ts", "../../node_modules/standardized-audio-context/src/helpers/split-import-statements.ts", "../../node_modules/standardized-audio-context/src/factories/add-audio-worklet-module.ts", "../../node_modules/standardized-audio-context/src/helpers/get-value-for-key.ts", "../../node_modules/standardized-audio-context/src/helpers/pick-element-from-set.ts", "../../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/get-event-listeners-of-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-active.ts", "../../node_modules/standardized-audio-context/src/guards/audio-worklet-node.ts", "../../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive.ts", "../../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive-when-necessary.ts", "../../node_modules/standardized-audio-context/src/factories/add-connection-to-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/add-passive-input-connection-to-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/add-silent-connection.ts", "../../node_modules/standardized-audio-context/src/factories/add-unrendered-audio-worklet-node.ts", "../../node_modules/standardized-audio-context/src/factories/analyser-node-constructor.ts", "../../node_modules/standardized-audio-context/src/helpers/is-owned-by-context.ts", "../../node_modules/standardized-audio-context/src/factories/analyser-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.ts", "../../node_modules/standardized-audio-context/src/factories/index-size-error.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-get-channel-data-method.ts", "../../node_modules/standardized-audio-context/src/factories/audio-buffer-constructor.ts", "../../node_modules/standardized-audio-context/src/constants.ts", "../../node_modules/standardized-audio-context/src/helpers/is-active-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/guards/audio-buffer-source-node.ts", "../../node_modules/standardized-audio-context/src/guards/biquad-filter-node.ts", "../../node_modules/standardized-audio-context/src/guards/constant-source-node.ts", "../../node_modules/standardized-audio-context/src/guards/gain-node.ts", "../../node_modules/standardized-audio-context/src/guards/oscillator-node.ts", "../../node_modules/standardized-audio-context/src/guards/stereo-panner-node.ts", "../../node_modules/standardized-audio-context/src/helpers/get-audio-node-connections.ts", "../../node_modules/standardized-audio-context/src/helpers/get-audio-param-connections.ts", "../../node_modules/standardized-audio-context/src/helpers/deactivate-active-audio-node-input-connections.ts", "../../node_modules/standardized-audio-context/src/helpers/deactivate-audio-graph.ts", "../../node_modules/standardized-audio-context/src/helpers/is-valid-latency-hint.ts", "../../node_modules/standardized-audio-context/src/factories/audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/audio-destination-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/audio-destination-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/audio-listener-factory.ts", "../../node_modules/standardized-audio-context/src/guards/audio-node.ts", "../../node_modules/standardized-audio-context/src/guards/audio-node-output-connection.ts", "../../node_modules/standardized-audio-context/src/helpers/insert-element-in-set.ts", "../../node_modules/standardized-audio-context/src/helpers/add-active-input-connection-to-audio-param.ts", "../../node_modules/standardized-audio-context/src/helpers/add-passive-input-connection-to-audio-param.ts", "../../node_modules/standardized-audio-context/src/guards/native-audio-node-faker.ts", "../../node_modules/standardized-audio-context/src/helpers/connect-native-audio-node-to-native-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection.ts", "../../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection-to-audio-param.ts", "../../node_modules/standardized-audio-context/src/helpers/delete-event-listeners-of-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-param.ts", "../../node_modules/standardized-audio-context/src/helpers/disconnect-native-audio-node-from-native-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/get-native-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/get-native-audio-param.ts", "../../node_modules/standardized-audio-context/src/helpers/is-part-of-a-cycle.ts", "../../node_modules/standardized-audio-context/src/helpers/is-passive-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-node-disconnect-method-support.ts", "../../node_modules/standardized-audio-context/src/helpers/visit-each-audio-node-once.ts", "../../node_modules/standardized-audio-context/src/guards/native-audio-node.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-node-disconnect-method.ts", "../../node_modules/standardized-audio-context/src/factories/audio-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/audio-param-factory.ts", "../../node_modules/standardized-audio-context/src/factories/audio-param-renderer.ts", "../../node_modules/standardized-audio-context/src/read-only-map.ts", "../../node_modules/standardized-audio-context/src/factories/audio-worklet-node-constructor.ts", "../../node_modules/standardized-audio-context/src/helpers/copy-from-channel.ts", "../../node_modules/standardized-audio-context/src/helpers/copy-to-channel.ts", "../../node_modules/standardized-audio-context/src/helpers/create-nested-arrays.ts", "../../node_modules/standardized-audio-context/src/helpers/get-audio-worklet-processor.ts", "../../node_modules/standardized-audio-context/src/factories/audio-worklet-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/base-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/biquad-filter-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/biquad-filter-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/cache-test-result.ts", "../../node_modules/standardized-audio-context/src/factories/channel-merger-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/channel-merger-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/channel-splitter-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/channel-splitter-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/connect-audio-param.ts", "../../node_modules/standardized-audio-context/src/factories/connect-multiple-outputs.ts", "../../node_modules/standardized-audio-context/src/factories/connected-native-audio-buffer-source-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/constant-source-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/constant-source-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/convert-number-to-unsigned-long.ts", "../../node_modules/standardized-audio-context/src/factories/convolver-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/convolver-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/create-native-offline-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/data-clone-error.ts", "../../node_modules/standardized-audio-context/src/helpers/detach-array-buffer.ts", "../../node_modules/standardized-audio-context/src/factories/decode-audio-data.ts", "../../node_modules/standardized-audio-context/src/factories/decrement-cycle-counter.ts", "../../node_modules/standardized-audio-context/src/factories/delay-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/delay-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/delete-active-input-connection-to-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/delete-unrendered-audio-worklet-node.ts", "../../node_modules/standardized-audio-context/src/guards/delay-node.ts", "../../node_modules/standardized-audio-context/src/factories/detect-cycles.ts", "../../node_modules/standardized-audio-context/src/factories/disconnect-multiple-outputs.ts", "../../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/encoding-error.ts", "../../node_modules/standardized-audio-context/src/factories/evaluate-source.ts", "../../node_modules/standardized-audio-context/src/factories/event-target-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/expose-current-frame-and-current-time.ts", "../../node_modules/standardized-audio-context/src/factories/fetch-source.ts", "../../node_modules/standardized-audio-context/src/factories/gain-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/gain-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/get-active-audio-worklet-node-inputs.ts", "../../node_modules/standardized-audio-context/src/factories/get-audio-node-renderer.ts", "../../node_modules/standardized-audio-context/src/factories/get-audio-node-tail-time.ts", "../../node_modules/standardized-audio-context/src/factories/get-audio-param-renderer.ts", "../../node_modules/standardized-audio-context/src/factories/get-backup-offline-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/invalid-state-error.ts", "../../node_modules/standardized-audio-context/src/factories/get-native-context.ts", "../../node_modules/standardized-audio-context/src/factories/get-or-create-backup-offline-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/get-unrendered-audio-worklet-nodes.ts", "../../node_modules/standardized-audio-context/src/factories/invalid-access-error.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-iir-filter-node-get-frequency-response-method.ts", "../../node_modules/standardized-audio-context/src/factories/iir-filter-node-constructor.ts", "../../node_modules/standardized-audio-context/src/helpers/filter-buffer.ts", "../../node_modules/standardized-audio-context/src/factories/iir-filter-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/increment-cycle-counter-factory.ts", "../../node_modules/standardized-audio-context/src/factories/is-any-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/is-any-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/is-any-audio-param.ts", "../../node_modules/standardized-audio-context/src/factories/is-any-offline-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/is-native-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/is-native-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/is-native-audio-param.ts", "../../node_modules/standardized-audio-context/src/factories/is-native-context.ts", "../../node_modules/standardized-audio-context/src/factories/is-native-offline-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/is-secure-context.ts", "../../node_modules/standardized-audio-context/src/factories/media-element-audio-source-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/media-stream-audio-destination-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/media-stream-audio-source-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/media-stream-track-audio-source-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/minimal-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/minimal-base-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/helpers/test-promise-support.ts", "../../node_modules/standardized-audio-context/src/factories/minimal-offline-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/monitor-connections.ts", "../../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-option.ts", "../../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-options.ts", "../../node_modules/standardized-audio-context/src/helpers/test-analyser-node-get-float-time-domain-data-method-support.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-analyser-node-get-float-time-domain-data-method.ts", "../../node_modules/standardized-audio-context/src/factories/native-analyser-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-buffer-constructor.ts", "../../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-audio-param-value.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-buffer-source-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-destination-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-constructor.ts", "../../node_modules/standardized-audio-context/src/helpers/test-clonability-of-audio-worklet-node-options.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-factory.ts", "../../node_modules/standardized-audio-context/src/helpers/compute-buffer-size.ts", "../../node_modules/standardized-audio-context/src/helpers/clone-audio-worklet-node-options.ts", "../../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor-promise.ts", "../../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor.ts", "../../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-faker-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-biquad-filter-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-channel-merger-node-factory.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-channel-splitter-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-channel-splitter-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-constant-source-node-factory.ts", "../../node_modules/standardized-audio-context/src/helpers/intercept-connections.ts", "../../node_modules/standardized-audio-context/src/factories/native-constant-source-node-faker-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-convolver-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-delay-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-dynamics-compressor-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-gain-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-faker-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-media-element-audio-source-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-destination-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-source-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-media-stream-track-audio-source-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-offline-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/native-oscillator-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-panner-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-panner-node-faker-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-periodic-wave-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-script-processor-node.ts", "../../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-faker-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-factory.ts", "../../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-faker-factory.ts", "../../node_modules/standardized-audio-context/src/factories/not-supported-error.ts", "../../node_modules/standardized-audio-context/src/factories/offline-audio-context-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/oscillator-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/oscillator-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/panner-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/panner-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/periodic-wave-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/render-automation.ts", "../../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-node.ts", "../../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-param.ts", "../../node_modules/standardized-audio-context/src/factories/render-native-offline-audio-context.ts", "../../node_modules/standardized-audio-context/src/factories/set-active-audio-worklet-node-inputs.ts", "../../node_modules/standardized-audio-context/src/factories/set-audio-node-tail-time.ts", "../../node_modules/standardized-audio-context/src/factories/start-rendering.ts", "../../node_modules/standardized-audio-context/src/factories/stereo-panner-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/stereo-panner-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/test-audio-buffer-constructor-support.ts", "../../node_modules/standardized-audio-context/src/factories/test-audio-worklet-processor-post-message-support.ts", "../../node_modules/standardized-audio-context/src/factories/test-offline-audio-context-current-time-support.ts", "../../node_modules/standardized-audio-context/src/factories/unknown-error.ts", "../../node_modules/standardized-audio-context/src/factories/wave-shaper-node-constructor.ts", "../../node_modules/standardized-audio-context/src/factories/wave-shaper-node-renderer-factory.ts", "../../node_modules/standardized-audio-context/src/factories/window.ts", "../../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods.ts", "../../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts", "../../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.ts", "../../node_modules/standardized-audio-context/src/factories/wrap-channel-merger-node.ts", "../../node_modules/standardized-audio-context/src/helpers/get-first-sample.ts", "../../node_modules/standardized-audio-context/src/helpers/is-dc-curve.ts", "../../node_modules/standardized-audio-context/src/helpers/overwrite-accessors.ts", "../../node_modules/standardized-audio-context/src/helpers/sanitize-audio-worklet-node-options.ts", "../../node_modules/standardized-audio-context/src/helpers/sanitize-channel-splitter-options.ts", "../../node_modules/standardized-audio-context/src/helpers/sanitize-periodic-wave-options.ts", "../../node_modules/standardized-audio-context/src/helpers/set-value-at-time-until-possible.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.ts", "../../node_modules/standardized-audio-context/src/helpers/test-audio-worklet-node-options-clonability.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts", "../../node_modules/standardized-audio-context/src/helpers/wrap-event-listener.ts", "../../node_modules/extendable-media-recorder/src/factories/web-audio-media-recorder.ts", "../../node_modules/extendable-media-recorder/src/factories/webm-pcm-media-recorder.ts", "../../node_modules/extendable-media-recorder/src/factories/window.ts", "../../node_modules/extendable-media-recorder/src/functions/read-variable-size-integer-length.ts", "../../node_modules/extendable-media-recorder/src/functions/wrap-event-listener.ts", "../../node_modules/extendable-media-recorder/src/module.ts", "../../node_modules/extendable-media-recorder-wav-encoder-broker/src/module.ts", "../../node_modules/extendable-media-recorder-wav-encoder/src/worker/worker.ts", "../../node_modules/extendable-media-recorder-wav-encoder/src/module.ts", "../../scripts/app.ts"],
  "sourcesContent": ["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n          }\n          return cache(collection, nextNumber);\n        }\n        // Quickly check if there is a theoretical chance to generate a new number.\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        }\n        // Otherwise use the full scale of safely usable integers.\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n}));\n", "function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var arrayWithoutHoles = require(\"./arrayWithoutHoles.js\");\nvar iterableToArray = require(\"./iterableToArray.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableSpread = require(\"./nonIterableSpread.js\");\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "/*!\n * dashify <https://github.com/jonschlinkert/dashify>\n *\n * Copyright (c) 2015-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = (str, options) => {\n  if (typeof str !== 'string') throw new TypeError('expected a string');\n  return str.trim()\n    .replace(/([a-z])([A-Z])/g, '$1-$2')\n    .replace(/\\W/g, m => /[\u00C0-\u017E]/.test(m) ? m : '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-{2,}/g, m => options && options.condense ? '-' : m)\n    .toLowerCase();\n};\n", "/*\n * indefinite-article.js v1.0.0, 12-18-2011\n *\n * @author: Rodrigo Neri (@rigoneri)\n *\n * (The MIT License)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nvar indefiniteArticle = function(phrase) {\n    var i, word;\n\n    // Getting the first word\n    var match = /\\w+/.exec(phrase);\n    if (match)\n        word = match[0];\n    else\n        return \"an\";\n\n    var l_word = word.toLowerCase();\n    // Specific start of words that should be preceeded by 'an'\n    var alt_cases = [\"honest\", \"hour\", \"hono\"];\n    for (i in alt_cases) {\n        if (l_word.indexOf(alt_cases[i]) == 0)\n            return \"an\";\n    }\n\n    // Single letter word which should be preceeded by 'an'\n    if (l_word.length == 1) {\n        if (\"aedhilmnorsx\".indexOf(l_word) >= 0)\n            return \"an\";\n        else\n            return \"a\";\n    }\n\n    // Capital words which should likely be preceeded by 'an'\n    if (word.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/)) {\n        return \"an\";\n    }\n\n    // Special cases where a word that begins with a vowel should be preceeded by 'a'\n    var regexes = [/^e[uw]/, /^onc?e\\b/, /^uni([^nmd]|mo)/, /^u[bcfhjkqrst][aeiou]/];\n    for (i = 0; i < regexes.length; i++) {\n        if (l_word.match(regexes[i]))\n            return \"a\"\n    }\n\n    // Special capital words (UK, UN)\n    if (word.match(/^U[NK][AIEO]/)) {\n        return \"a\";\n    }\n    else if (word == word.toUpperCase()) {\n        if (\"aedhilmnorsx\".indexOf(l_word[0]) >= 0)\n            return \"an\";\n        else\n            return \"a\";\n    }\n\n    // Basic method of words that begin with a vowel being preceeded by 'an'\n    if (\"aeiou\".indexOf(l_word[0]) >= 0)\n        return \"an\";\n\n    // Instances where y follwed by specific letters is preceeded by 'an'\n    if (l_word.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/))\n        return \"an\";\n\n    return \"a\";\n};\n\nif ((typeof module !== 'undefined') && (typeof module.exports !== 'undefined')) {\n    module.exports = indefiniteArticle;\n} else {\n    window.indefiniteArticle = indefiniteArticle;\n}\n", "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/toConsumableArray'), require('dashify'), require('indefinite-article')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/toConsumableArray', 'dashify', 'indefinite-article'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.compilerr = {}, global._toConsumableArray, global.dashify, global.indefiniteArticle));\n})(this, (function (exports, _toConsumableArray, dashify, indefiniteArticle) { 'use strict';\n\n    var applyModifiers = function applyModifiers(name, modifiers) {\n      if (modifiers === undefined) {\n        return name;\n      }\n      return modifiers.reduce(function (modifiedName, modifier) {\n        if (modifier === 'capitalize') {\n          var head = modifiedName.charAt(0).toUpperCase();\n          var tail = modifiedName.slice(1);\n          return \"\".concat(head).concat(tail);\n        }\n        if (modifier === 'dashify') {\n          return dashify(modifiedName);\n        }\n        if (modifier === 'prependIndefiniteArticle') {\n          return \"\".concat(indefiniteArticle(modifiedName), \" \").concat(modifiedName);\n        }\n        return modifiedName;\n      }, name);\n    };\n    var buildRegex = function buildRegex(variable) {\n      var expression = variable.name + variable.modifiers.map(function (modifier) {\n        return \"\\\\.\".concat(modifier, \"\\\\(\\\\)\");\n      }).join('');\n      return new RegExp(\"\\\\$\\\\{\".concat(expression, \"}\"), 'g');\n    };\n    var preRenderString = function preRenderString(string, parameters) {\n      var expressionRegex = /\\${([^.}]+)((\\.[^(]+\\(\\))*)}/g;\n      var variables = [];\n      var expressionResult = expressionRegex.exec(string);\n      while (expressionResult !== null) {\n        var variable = {\n          modifiers: [],\n          name: expressionResult[1]\n        };\n        if (expressionResult[3] !== undefined) {\n          var modifiersRegex = /\\.[^(]+\\(\\)/g;\n          var modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);\n          while (modifiersRegexResult !== null) {\n            variable.modifiers.push(modifiersRegexResult[0].slice(1, -2));\n            modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);\n          }\n        }\n        variables.push(variable);\n        expressionResult = expressionRegex.exec(string);\n      }\n      var preRenderedParts = variables.reduce(function (parts, variable) {\n        return parts.map(function (part) {\n          if (typeof part === 'string') {\n            return part.split(buildRegex(variable)).reduce(function (prts, prt, index) {\n              if (index === 0) {\n                return [prt];\n              }\n              if (variable.name in parameters) {\n                return [].concat(_toConsumableArray(prts), [applyModifiers(parameters[variable.name], variable.modifiers), prt]);\n              }\n              return [].concat(_toConsumableArray(prts), [function (prmtrs) {\n                return applyModifiers(prmtrs[variable.name], variable.modifiers);\n              }, prt]);\n            }, []);\n          }\n          return [part];\n        }).reduce(function (prts, part) {\n          return [].concat(_toConsumableArray(prts), _toConsumableArray(part));\n        }, []);\n      }, [string]);\n      return function (missingParameters) {\n        return preRenderedParts.reduce(function (renderedParts, preRenderedPart) {\n          if (typeof preRenderedPart === 'string') {\n            return [].concat(_toConsumableArray(renderedParts), [preRenderedPart]);\n          }\n          return [].concat(_toConsumableArray(renderedParts), [preRenderedPart(missingParameters)]);\n        }, []).join('');\n      };\n    };\n    var compile = function compile(template) {\n      var knownParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var renderCode = template.code === undefined ? undefined : preRenderString(template.code, knownParameters);\n      var renderMessage = template.message === undefined ? undefined : preRenderString(template.message, knownParameters);\n      function render() {\n        var causeOrMissingParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var optionalCause = arguments.length > 1 ? arguments[1] : undefined;\n        var hasNoOptionalCause = optionalCause === undefined && (causeOrMissingParameters instanceof Error || causeOrMissingParameters.code !== undefined && causeOrMissingParameters.code.slice(-9) === 'Exception');\n        var _ref = hasNoOptionalCause ? {\n            cause: causeOrMissingParameters,\n            missingParameters: {}\n          } : {\n            cause: optionalCause,\n            missingParameters: causeOrMissingParameters\n          },\n          cause = _ref.cause,\n          missingParameters = _ref.missingParameters;\n        var err = renderMessage === undefined ? new Error() : new Error(renderMessage(missingParameters));\n        if (cause !== null) {\n          err.cause = cause;\n        }\n        if (renderCode !== undefined) {\n          err.code = renderCode(missingParameters);\n        }\n        if (template.status !== undefined) {\n          err.status = template.status;\n        }\n        return err;\n      }\n      return render;\n    };\n\n    exports.compile = compile;\n\n}));\n", "function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : String(i);\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n        target = _ref.target,\n        timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      if (valueAtStartTime === value) {\n        return value;\n      }\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n        startTime = _ref.startTime,\n        values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function (_Symbol$iterator) {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n      _createClass(AutomationEventList, [{\n        key: _Symbol$iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n              }\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            var removedAutomationEvent = this._automationEvents[index];\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n                var startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                var duration = eventTime - lastAutomationEvent.startTime;\n                var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                var length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                var fraction = duration / (length - 1) * ratio;\n                var values = lastAutomationEvent.values.slice(0, length);\n                if (fraction < 1) {\n                  for (var i = 1; i < length; i += 1) {\n                    var factor = fraction * i % 1;\n                    values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                  }\n                }\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n          var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n          var nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n          var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n          var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n              startTime = _getEndTimeAndValueOf2[0],\n              value = _getEndTimeAndValueOf2[1];\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n              _startTime = _getEndTimeAndValueOf4[0],\n              _value = _getEndTimeAndValueOf4[1];\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n          return this._defaultValue;\n        }\n      }]);\n      return AutomationEventList;\n    }(Symbol.iterator);\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n}));\n", "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.multiBufferDataView = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n    var MultiBufferDataView = /*#__PURE__*/function () {\n      function MultiBufferDataView(buffers) {\n        var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var byteLength = arguments.length > 2 ? arguments[2] : undefined;\n        _classCallCheck(this, MultiBufferDataView);\n        if (byteOffset < 0 || byteLength !== undefined && byteLength < 0) {\n          throw new RangeError();\n        }\n        var availableBytes = buffers.reduce(function (length, buffer) {\n          return length + buffer.byteLength;\n        }, 0);\n        if (byteOffset > availableBytes || byteLength !== undefined && byteOffset + byteLength > availableBytes) {\n          throw new RangeError();\n        }\n        var dataViews = [];\n        var effectiveByteLength = byteLength === undefined ? availableBytes - byteOffset : byteLength;\n        var truncatedBuffers = [];\n        var consumedByteLength = 0;\n        var truncatedByteOffset = byteOffset;\n        var _iterator = _createForOfIteratorHelper(buffers),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var buffer = _step.value;\n            if (truncatedBuffers.length === 0) {\n              if (buffer.byteLength > truncatedByteOffset) {\n                consumedByteLength = buffer.byteLength - truncatedByteOffset;\n                var byteLengthOfDataView = consumedByteLength > effectiveByteLength ? effectiveByteLength : consumedByteLength;\n                dataViews.push(new DataView(buffer, truncatedByteOffset, byteLengthOfDataView));\n                truncatedBuffers.push(buffer);\n              } else {\n                truncatedByteOffset -= buffer.byteLength;\n              }\n            } else if (consumedByteLength < effectiveByteLength) {\n              consumedByteLength += buffer.byteLength;\n              var _byteLengthOfDataView = consumedByteLength > effectiveByteLength ? buffer.byteLength - consumedByteLength + effectiveByteLength : buffer.byteLength;\n              dataViews.push(new DataView(buffer, 0, _byteLengthOfDataView));\n              truncatedBuffers.push(buffer);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this._buffers = truncatedBuffers;\n        this._byteLength = effectiveByteLength;\n        this._byteOffset = truncatedByteOffset;\n        this._dataViews = dataViews;\n        this._internalBuffer = new DataView(new ArrayBuffer(8));\n      }\n      _createClass(MultiBufferDataView, [{\n        key: \"buffers\",\n        get: function get() {\n          return this._buffers;\n        }\n      }, {\n        key: \"byteLength\",\n        get: function get() {\n          return this._byteLength;\n        }\n      }, {\n        key: \"byteOffset\",\n        get: function get() {\n          return this._byteOffset;\n        }\n      }, {\n        key: \"getFloat32\",\n        value: function getFloat32(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n          return this._internalBuffer.getFloat32(0, littleEndian);\n        }\n      }, {\n        key: \"getFloat64\",\n        value: function getFloat64(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n          this._internalBuffer.setUint8(4, this.getUint8(byteOffset + 4));\n          this._internalBuffer.setUint8(5, this.getUint8(byteOffset + 5));\n          this._internalBuffer.setUint8(6, this.getUint8(byteOffset + 6));\n          this._internalBuffer.setUint8(7, this.getUint8(byteOffset + 7));\n          return this._internalBuffer.getFloat64(0, littleEndian);\n        }\n      }, {\n        key: \"getInt16\",\n        value: function getInt16(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n          return this._internalBuffer.getInt16(0, littleEndian);\n        }\n      }, {\n        key: \"getInt32\",\n        value: function getInt32(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n          return this._internalBuffer.getInt32(0, littleEndian);\n        }\n      }, {\n        key: \"getInt8\",\n        value: function getInt8(byteOffset) {\n          var _this$_findDataViewWi = this._findDataViewWithOffset(byteOffset),\n            _this$_findDataViewWi2 = _slicedToArray(_this$_findDataViewWi, 2),\n            dataView = _this$_findDataViewWi2[0],\n            byteOffsetOfDataView = _this$_findDataViewWi2[1];\n          return dataView.getInt8(byteOffset - byteOffsetOfDataView);\n        }\n      }, {\n        key: \"getUint16\",\n        value: function getUint16(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n          return this._internalBuffer.getUint16(0, littleEndian);\n        }\n      }, {\n        key: \"getUint32\",\n        value: function getUint32(byteOffset, littleEndian) {\n          this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n          this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n          this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n          this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n          return this._internalBuffer.getUint32(0, littleEndian);\n        }\n      }, {\n        key: \"getUint8\",\n        value: function getUint8(byteOffset) {\n          var _this$_findDataViewWi3 = this._findDataViewWithOffset(byteOffset),\n            _this$_findDataViewWi4 = _slicedToArray(_this$_findDataViewWi3, 2),\n            dataView = _this$_findDataViewWi4[0],\n            byteOffsetOfDataView = _this$_findDataViewWi4[1];\n          return dataView.getUint8(byteOffset - byteOffsetOfDataView);\n        }\n      }, {\n        key: \"setFloat32\",\n        value: function setFloat32(byteOffset, value, littleEndian) {\n          this._internalBuffer.setFloat32(0, value, littleEndian);\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n        }\n      }, {\n        key: \"setFloat64\",\n        value: function setFloat64(byteOffset, value, littleEndian) {\n          this._internalBuffer.setFloat64(0, value, littleEndian);\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n          this.setUint8(byteOffset + 4, this._internalBuffer.getUint8(4));\n          this.setUint8(byteOffset + 5, this._internalBuffer.getUint8(5));\n          this.setUint8(byteOffset + 6, this._internalBuffer.getUint8(6));\n          this.setUint8(byteOffset + 7, this._internalBuffer.getUint8(7));\n        }\n      }, {\n        key: \"setInt16\",\n        value: function setInt16(byteOffset, value, littleEndian) {\n          this._internalBuffer.setInt16(0, value, littleEndian);\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n        }\n      }, {\n        key: \"setInt32\",\n        value: function setInt32(byteOffset, value, littleEndian) {\n          this._internalBuffer.setInt32(0, value, littleEndian);\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n        }\n      }, {\n        key: \"setInt8\",\n        value: function setInt8(byteOffset, value) {\n          var _this$_findDataViewWi5 = this._findDataViewWithOffset(byteOffset),\n            _this$_findDataViewWi6 = _slicedToArray(_this$_findDataViewWi5, 2),\n            dataView = _this$_findDataViewWi6[0],\n            byteOffsetOfDataView = _this$_findDataViewWi6[1];\n          dataView.setInt8(byteOffset - byteOffsetOfDataView, value);\n        }\n      }, {\n        key: \"setUint16\",\n        value: function setUint16(byteOffset, value, littleEndian) {\n          this._internalBuffer.setUint16(0, value, littleEndian);\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n        }\n      }, {\n        key: \"setUint32\",\n        value: function setUint32(byteOffset, value, littleEndian) {\n          this._internalBuffer.setUint32(0, value, littleEndian);\n          this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n          this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n          this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n          this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n        }\n      }, {\n        key: \"setUint8\",\n        value: function setUint8(byteOffset, value) {\n          var _this$_findDataViewWi7 = this._findDataViewWithOffset(byteOffset),\n            _this$_findDataViewWi8 = _slicedToArray(_this$_findDataViewWi7, 2),\n            dataView = _this$_findDataViewWi8[0],\n            byteOffsetOfDataView = _this$_findDataViewWi8[1];\n          dataView.setUint8(byteOffset - byteOffsetOfDataView, value);\n        }\n      }, {\n        key: \"_findDataViewWithOffset\",\n        value: function _findDataViewWithOffset(byteOffset) {\n          var byteOffsetOfDataView = 0;\n          var _iterator2 = _createForOfIteratorHelper(this._dataViews),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var dataView = _step2.value;\n              var byteOffsetOfNextDataView = byteOffsetOfDataView + dataView.byteLength;\n              if (byteOffset >= byteOffsetOfDataView && byteOffset < byteOffsetOfNextDataView) {\n                return [dataView, byteOffsetOfDataView];\n              }\n              byteOffsetOfDataView = byteOffsetOfNextDataView;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          throw new RangeError();\n        }\n      }]);\n      return MultiBufferDataView;\n    }();\n\n    exports.MultiBufferDataView = MultiBufferDataView;\n\n}));\n", "import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { IWorkerDefinition, IWorkerErrorMessage, IWorkerResultMessage } from 'worker-factory';\nimport { isMessagePort } from './guards/message-port';\nimport { extendBrokerImplementation } from './helpers/extend-broker-implementation';\nimport { IBrokerDefinition, IDefaultBrokerDefinition, IWorkerEvent } from './interfaces';\nimport { TBrokerImplementation } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst ONGOING_REQUESTS = new WeakMap<MessagePort | Worker, Map<number, { reject: Function; resolve: Function }>>();\n\nconst createOrGetOngoingRequests = (sender: MessagePort | Worker): Map<number, { reject: Function; resolve: Function }> => {\n    if (ONGOING_REQUESTS.has(sender)) {\n        // @todo TypeScript needs to be convinced that has() works as expected.\n        return <Map<number, { reject: Function; resolve: Function }>>ONGOING_REQUESTS.get(sender);\n    }\n\n    const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n\n    ONGOING_REQUESTS.set(sender, ongoingRequests);\n\n    return ongoingRequests;\n};\n\nexport const createBroker = <T extends IBrokerDefinition, U extends IWorkerDefinition>(\n    brokerImplementation: TBrokerImplementation<T, U>\n): ((sender: MessagePort | Worker) => T & IDefaultBrokerDefinition) => {\n    const fullBrokerImplementation = extendBrokerImplementation(brokerImplementation);\n\n    return (sender: MessagePort | Worker) => {\n        const ongoingRequests = createOrGetOngoingRequests(sender);\n\n        sender.addEventListener('message', <EventListener>(({ data: message }: IWorkerEvent) => {\n            const { id } = message;\n\n            if (id !== null && ongoingRequests.has(id)) {\n                const { reject, resolve } = <{ reject: Function; resolve: Function }>ongoingRequests.get(id);\n\n                ongoingRequests.delete(id);\n\n                if ((<IWorkerErrorMessage>message).error === undefined) {\n                    resolve((<IWorkerResultMessage>message).result);\n                } else {\n                    reject(new Error((<IWorkerErrorMessage>message).error.message));\n                }\n            }\n        }));\n\n        if (isMessagePort(sender)) {\n            sender.start();\n        }\n\n        const call = <V extends keyof U>(method: V, params: U[V]['params'] = null, transferables: U[V]['transferables'] = []) => {\n            return new Promise<U[V]['response']['result']>((resolve, reject) => {\n                const id = generateUniqueNumber(ongoingRequests);\n\n                ongoingRequests.set(id, { reject, resolve });\n\n                if (params === null) {\n                    sender.postMessage({ id, method }, <Transferable[]>transferables);\n                } else {\n                    sender.postMessage({ id, method, params }, <Transferable[]>transferables);\n                }\n            });\n        };\n        const notify = <V extends keyof U>(method: V, params: U[V]['params'], transferables: U[V]['transferables'] = []) => {\n            sender.postMessage({ id: null, method, params }, <Transferable[]>transferables);\n        };\n\n        let functions: object = {};\n\n        for (const [key, handler] of Object.entries(fullBrokerImplementation)) {\n            functions = { ...functions, [key]: handler({ call, notify }) };\n        }\n\n        return <T & IDefaultBrokerDefinition>{ ...functions };\n    };\n};\n", "export const isMessagePort = (sender: MessagePort | Worker): sender is MessagePort => {\n    return typeof (<MessagePort>sender).start === 'function';\n};\n", "export const PORT_MAP: WeakMap<MessagePort, number> = new WeakMap();\n", "import { IWorkerDefinition } from 'worker-factory';\nimport { IBrokerDefinition, IDefaultBrokerDefinition } from '../interfaces';\nimport { TBrokerImplementation } from '../types';\nimport { PORT_MAP } from './port-map';\n\nexport const extendBrokerImplementation = <T extends IBrokerDefinition, U extends IWorkerDefinition>(\n    partialBrokerImplementation: TBrokerImplementation<T, U>\n): TBrokerImplementation<T & IDefaultBrokerDefinition, U> =>\n    <TBrokerImplementation<T & IDefaultBrokerDefinition, U>>{\n        ...partialBrokerImplementation,\n        connect: ({ call }) => {\n            return async (): Promise<MessagePort> => {\n                const { port1, port2 } = new MessageChannel();\n\n                const portId = <number>await call('connect', { port: port1 }, [port1]);\n\n                PORT_MAP.set(port2, portId);\n\n                return port2;\n            };\n        },\n        disconnect: ({ call }) => {\n            return async (port: MessagePort): Promise<void> => {\n                const portId = PORT_MAP.get(port);\n\n                if (portId === undefined) {\n                    throw new Error('The given port is not connected.');\n                }\n\n                await call('disconnect', { portId });\n            };\n        },\n        isSupported: ({ call }) => {\n            return () => call('isSupported');\n        }\n    };\n", "import { createBroker } from 'broker-factory';\nimport { addUniqueNumber } from 'fast-unique-numbers';\nimport { TMediaEncoderHostWorkerDefinition } from 'media-encoder-host-worker';\nimport { IMediaEncoderHostBrokerDefinition } from './interfaces';\nimport { TMediaEncoderHostBrokerLoader, TMediaEncoderHostBrokerWrapper } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst encoderIds: Set<number> = new Set();\n\nexport const wrap: TMediaEncoderHostBrokerWrapper = createBroker<IMediaEncoderHostBrokerDefinition, TMediaEncoderHostWorkerDefinition>({\n    encode: ({ call }) => {\n        return async (encoderId, timeslice) => {\n            const arrayBuffers = await call('encode', { encoderId, timeslice });\n\n            encoderIds.delete(encoderId);\n\n            return arrayBuffers;\n        };\n    },\n    instantiate: ({ call }) => {\n        return async (mimeType, sampleRate) => {\n            const encoderId = addUniqueNumber(encoderIds);\n            const port = await call('instantiate', { encoderId, mimeType, sampleRate });\n\n            return { encoderId, port };\n        };\n    },\n    register: ({ call }) => {\n        return (port) => {\n            return call('register', { port }, [port]);\n        };\n    }\n});\n\nexport const load: TMediaEncoderHostBrokerLoader = (url: string) => {\n    const worker = new Worker(url);\n\n    return wrap(worker);\n};\n", "// This is the minified and stringified code of the media-encoder-host-worker package.\nexport const worker = `(()=>{var e={775:function(e,t,r){!function(e,t,r,n){\"use strict\";var o=function(e,t){return void 0===t?e:t.reduce((function(e,t){if(\"capitalize\"===t){var o=e.charAt(0).toUpperCase(),s=e.slice(1);return\"\".concat(o).concat(s)}return\"dashify\"===t?r(e):\"prependIndefiniteArticle\"===t?\"\".concat(n(e),\" \").concat(e):e}),e)},s=function(e){var t=e.name+e.modifiers.map((function(e){return\"\\\\\\\\.\".concat(e,\"\\\\\\\\(\\\\\\\\)\")})).join(\"\");return new RegExp(\"\\\\\\\\$\\\\\\\\{\".concat(t,\"}\"),\"g\")},a=function(e,r){for(var n=/\\\\\\${([^.}]+)((\\\\.[^(]+\\\\(\\\\))*)}/g,a=[],i=n.exec(e);null!==i;){var c={modifiers:[],name:i[1]};if(void 0!==i[3])for(var u=/\\\\.[^(]+\\\\(\\\\)/g,l=u.exec(i[2]);null!==l;)c.modifiers.push(l[0].slice(1,-2)),l=u.exec(i[2]);a.push(c),i=n.exec(e)}var d=a.reduce((function(e,n){return e.map((function(e){return\"string\"==typeof e?e.split(s(n)).reduce((function(e,s,a){return 0===a?[s]:n.name in r?[].concat(t(e),[o(r[n.name],n.modifiers),s]):[].concat(t(e),[function(e){return o(e[n.name],n.modifiers)},s])}),[]):[e]})).reduce((function(e,r){return[].concat(t(e),t(r))}),[])}),[e]);return function(e){return d.reduce((function(r,n){return[].concat(t(r),\"string\"==typeof n?[n]:[n(e)])}),[]).join(\"\")}},i=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=void 0===e.code?void 0:a(e.code,t),n=void 0===e.message?void 0:a(e.message,t);function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1?arguments[1]:void 0,s=void 0===o&&(t instanceof Error||void 0!==t.code&&\"Exception\"===t.code.slice(-9))?{cause:t,missingParameters:{}}:{cause:o,missingParameters:t},a=s.cause,i=s.missingParameters,c=void 0===n?new Error:new Error(n(i));return null!==a&&(c.cause=a),void 0!==r&&(c.code=r(i)),void 0!==e.status&&(c.status=e.status),c}return o};e.compile=i}(t,r(106),r(881),r(507))},881:e=>{\"use strict\";e.exports=(e,t)=>{if(\"string\"!=typeof e)throw new TypeError(\"expected a string\");return e.trim().replace(/([a-z])([A-Z])/g,\"$1-$2\").replace(/\\\\W/g,(e=>/[\u00C0-\u017E]/.test(e)?e:\"-\")).replace(/^-+|-+$/g,\"\").replace(/-{2,}/g,(e=>t&&t.condense?\"-\":e)).toLowerCase()}},107:function(e,t){!function(e){\"use strict\";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),i=void 0===a?r.size:a<s?a+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*s);return e(r,i)}if(r.size>n)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,c=r(i),u=a(c,i),l=t(u);e.addUniqueNumber=l,e.generateUniqueNumber=u}(t)},507:e=>{var t=function(e){var t,r,n=/\\\\w+/.exec(e);if(!n)return\"an\";var o=(r=n[0]).toLowerCase(),s=[\"honest\",\"hour\",\"hono\"];for(t in s)if(0==o.indexOf(s[t]))return\"an\";if(1==o.length)return\"aedhilmnorsx\".indexOf(o)>=0?\"an\":\"a\";if(r.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/))return\"an\";var a=[/^e[uw]/,/^onc?e\\\\b/,/^uni([^nmd]|mo)/,/^u[bcfhjkqrst][aeiou]/];for(t=0;t<a.length;t++)if(o.match(a[t]))return\"a\";return r.match(/^U[NK][AIEO]/)?\"a\":r==r.toUpperCase()?\"aedhilmnorsx\".indexOf(o[0])>=0?\"an\":\"a\":\"aeiou\".indexOf(o[0])>=0||o.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/)?\"an\":\"a\"};void 0!==e.exports?e.exports=t:window.indefiniteArticle=t},768:e=>{e.exports=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n},e.exports.__esModule=!0,e.exports.default=e.exports},907:(e,t,r)=>{var n=r(768);e.exports=function(e){if(Array.isArray(e))return n(e)},e.exports.__esModule=!0,e.exports.default=e.exports},642:e=>{e.exports=function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)},e.exports.__esModule=!0,e.exports.default=e.exports},344:e=>{e.exports=function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")},e.exports.__esModule=!0,e.exports.default=e.exports},106:(e,t,r)=>{var n=r(907),o=r(642),s=r(906),a=r(344);e.exports=function(e){return n(e)||o(e)||s(e)||a()},e.exports.__esModule=!0,e.exports.default=e.exports},906:(e,t,r)=>{var n=r(768);e.exports=function(e,t){if(e){if(\"string\"==typeof e)return n(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?n(e,t):void 0}},e.exports.__esModule=!0,e.exports.default=e.exports}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{\"use strict\";var e=r(775);const t=-32603,n=-32602,o=-32601,s=(0,e.compile)({message:'The requested method called \"\\${method}\" is not supported.',status:o}),a=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned no required result.',status:t}),i=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned an unexpected result.',status:t}),c=(0,e.compile)({message:'The specified parameter called \"portId\" with the given value \"\\${portId}\" does not identify a port connected to this worker.',status:n});var u=r(107);const l=new Map,d=(e,t,r)=>({...t,connect:r=>{let{port:n}=r;n.start();const o=e(n,t),s=(0,u.generateUniqueNumber)(l);return l.set(s,(()=>{o(),n.close(),l.delete(s)})),{result:s}},disconnect:e=>{let{portId:t}=e;const r=l.get(t);if(void 0===r)throw c({portId:t.toString()});return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=r();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),f=function(e,t){const r=d(f,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0),n=((e,t)=>async r=>{let{data:{id:n,method:o,params:c}}=r;const u=t[o];try{if(void 0===u)throw s({method:o});const t=void 0===c?u():u(c);if(void 0===t)throw a({method:o});const r=t instanceof Promise?await t:t;if(null===n){if(void 0!==r.result)throw i({method:o})}else{if(void 0===r.result)throw i({method:o});const{result:t,transferables:s=[]}=r;e.postMessage({id:n,result:t},s)}}catch(t){const{message:r,status:o=-32603}=t;e.postMessage({error:{code:o,message:r},id:n})}})(e,r);return e.addEventListener(\"message\",n),()=>e.removeEventListener(\"message\",n)},p=e=>{e.onmessage=null,e.close()},m=new WeakMap,h=new WeakMap,g=(e=>{const t=(r=e,{...r,connect:e=>{let{call:t}=e;return async()=>{const{port1:e,port2:r}=new MessageChannel,n=await t(\"connect\",{port:e},[e]);return m.set(r,n),r}},disconnect:e=>{let{call:t}=e;return async e=>{const r=m.get(e);if(void 0===r)throw new Error(\"The given port is not connected.\");await t(\"disconnect\",{portId:r})}},isSupported:e=>{let{call:t}=e;return()=>t(\"isSupported\")}});var r;return e=>{const r=(e=>{if(h.has(e))return h.get(e);const t=new Map;return h.set(e,t),t})(e);e.addEventListener(\"message\",(e=>{let{data:t}=e;const{id:n}=t;if(null!==n&&r.has(n)){const{reject:e,resolve:o}=r.get(n);r.delete(n),void 0===t.error?o(t.result):e(new Error(t.error.message))}})),(e=>\"function\"==typeof e.start)(e)&&e.start();const n=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return new Promise(((s,a)=>{const i=(0,u.generateUniqueNumber)(r);r.set(i,{reject:a,resolve:s}),null===n?e.postMessage({id:i,method:t},o):e.postMessage({id:i,method:t,params:n},o)}))},o=function(t,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];e.postMessage({id:null,method:t,params:r},n)};let s={};for(const[e,r]of Object.entries(t))s={...s,[e]:r({call:n,notify:o})};return{...s}}})({characterize:e=>{let{call:t}=e;return()=>t(\"characterize\")},encode:e=>{let{call:t}=e;return(e,r)=>t(\"encode\",{recordingId:e,timeslice:r})},record:e=>{let{call:t}=e;return async(e,r,n)=>{await t(\"record\",{recordingId:e,sampleRate:r,typedArrays:n},n.map((e=>{let{buffer:t}=e;return t})))}}}),v=async(e,t)=>{const r=g(t),n=await r.characterize(),o=n.toString();if(e.has(o))throw new Error(\"There is already an encoder stored which handles exactly the same mime types.\");return e.set(o,[n,r]),n},w=new Map,x=(e=>t=>{const r=e.get(t);if(void 0===r)throw new Error(\"There was no instance of an encoder stored with the given id.\");return r})(w),y=((e,t)=>r=>{const n=t(r);return e.delete(r),n})(w,x),M=new Map,b=((e,t)=>r=>{const[n,o,s,a]=t(r);return s?new Promise((t=>{o.onmessage=s=>{let{data:i}=s;0===i.length?(e(o),t(n.encode(r,null))):n.record(r,a,i)}})):n.encode(r,null)})(p,y),E=(e=>t=>{for(const[r,n]of Array.from(e.values()))if(r.test(t))return n;throw new Error(\"There is no encoder registered which could handle the given mimeType.\")})(M),A=((e,t,r)=>(n,o,s)=>{if(t.has(n))throw new Error('There is already an encoder registered with an id called \"'.concat(n,'\".'));const a=r(o),{port1:i,port2:c}=new MessageChannel,u=[a,i,!0,s];return t.set(n,u),i.onmessage=t=>{let{data:r}=t;0===r.length?(e(i),u[2]=!1):a.record(n,s,r.map((e=>\"number\"==typeof e?new Float32Array(e):e)))},c})(p,w,E),I=(e=>(t,r)=>{const[n]=e(t);return n.encode(t,r)})(x);f(self,{encode:async e=>{let{encoderId:t,timeslice:r}=e;const n=null===r?await b(t):await I(t,r);return{result:n,transferables:n}},instantiate:e=>{let{encoderId:t,mimeType:r,sampleRate:n}=e;const o=A(t,r,n);return{result:o,transferables:[o]}},register:async e=>{let{port:t}=e;return{result:await v(M,t)}}})})()})();`; // tslint:disable-line:max-line-length\n", "import { load as loadWorker } from 'media-encoder-host-broker';\nimport { worker } from './worker/worker';\n\nconst blob: Blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n\nconst url: string = URL.createObjectURL(blob);\n\nconst mediaEncoderHost = loadWorker(url);\n\nexport const connect = mediaEncoderHost.connect;\n\nexport const disconnect = mediaEncoderHost.disconnect;\n\nexport const encode = mediaEncoderHost.encode;\n\nexport const instantiate = mediaEncoderHost.instantiate;\n\nexport const isSupported = mediaEncoderHost.isSupported;\n\nexport const register = mediaEncoderHost.register;\n\nURL.revokeObjectURL(url);\n", "import { TBlobEventFactoryFactory } from '../types';\n\nexport const createBlobEventFactory: TBlobEventFactoryFactory = (nativeBlobEventConstructor) => {\n    return (type, blobEventInit) => {\n        if (nativeBlobEventConstructor === null) {\n            throw new Error('A native BlobEvent could not be created.');\n        }\n\n        return new nativeBlobEventConstructor(type, blobEventInit);\n    };\n};\n", "import { TDecodeWebMChunkFactory } from '../types';\n\nexport const createDecodeWebMChunk: TDecodeWebMChunkFactory = (readElementContent, readElementType) => {\n    return (dataView, elementType, channelCount) => {\n        const contents: (readonly Float32Array[])[] = [];\n\n        let currentElementType = elementType;\n        let offset = 0;\n\n        while (offset < dataView.byteLength) {\n            if (currentElementType === null) {\n                const lengthAndType = readElementType(dataView, offset);\n\n                if (lengthAndType === null) {\n                    break;\n                }\n\n                const { length, type } = lengthAndType;\n\n                currentElementType = type;\n                offset += length;\n            } else {\n                const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n\n                if (contentAndLength === null) {\n                    break;\n                }\n\n                const { content, length } = contentAndLength;\n\n                currentElementType = null;\n                offset += length;\n\n                if (content !== null) {\n                    contents.push(content);\n                }\n            }\n        }\n\n        return { contents, currentElementType, offset };\n    };\n};\n", "import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (createEventTarget, wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        private _nativeEventTarget: TNativeEventTarget;\n\n        constructor(nativeEventTarget: null | TNativeEventTarget = null) {\n            this._listeners = new WeakMap();\n            this._nativeEventTarget = nativeEventTarget === null ? createEventTarget() : nativeEventTarget;\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n", "import { TEventTargetFactoryFactory } from '../types';\n\nexport const createEventTargetFactory: TEventTargetFactoryFactory = (window) => {\n    return () => {\n        if (window === null) {\n            throw new Error('A native EventTarget could not be created.');\n        }\n\n        return window.document.createElement('p');\n    };\n};\n", "import { TInvalidModificationErrorFactory } from '../types';\n\nexport const createInvalidModificationError: TInvalidModificationErrorFactory = (message = '') => {\n    try {\n        return new DOMException(message, 'InvalidModificationError');\n    } catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 13;\n        err.message = message;\n        err.name = 'InvalidModificationError';\n\n        return err;\n    }\n};\n", "import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    } catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n\n        return err;\n    }\n};\n", "import { IMediaRecorder, IMediaRecorderEventMap, IMediaRecorderOptions } from '../interfaces';\nimport {\n    TBlobEventHandler,\n    TErrorEventHandler,\n    TEventHandler,\n    TMediaRecorderConstructorFactory,\n    TNativeEventTarget,\n    TRecordingState\n} from '../types';\n\nexport const createMediaRecorderConstructor: TMediaRecorderConstructorFactory = (\n    createNativeMediaRecorder,\n    createNotSupportedError,\n    createWebAudioMediaRecorder,\n    createWebmPcmMediaRecorder,\n    encoderRegexes,\n    eventTargetConstructor,\n    nativeMediaRecorderConstructor\n) => {\n    return class MediaRecorder extends eventTargetConstructor<IMediaRecorderEventMap> implements IMediaRecorder {\n        private _internalMediaRecorder: Omit<\n            IMediaRecorder,\n            'ondataavailable' | 'onerror' | 'onpause' | 'onresume' | 'onstart' | 'onstop' | keyof TNativeEventTarget\n        >;\n\n        private _ondataavailable: null | [TBlobEventHandler<this>, TBlobEventHandler<this>];\n\n        private _onerror: null | [TErrorEventHandler<this>, TErrorEventHandler<this>];\n\n        private _onpause: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onresume: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstart: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstop: null | [TEventHandler<this>, TEventHandler<this>];\n\n        constructor(stream: MediaStream, options: IMediaRecorderOptions = {}) {\n            const { mimeType } = options;\n\n            if (\n                nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                (mimeType === undefined ||\n                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))\n            ) {\n                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n\n                super(internalMediaRecorder);\n\n                this._internalMediaRecorder = internalMediaRecorder;\n            } else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {\n                super();\n\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                if (\n                    nativeMediaRecorderConstructor !== null &&\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')\n                ) {\n                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n                } else {\n                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n                }\n            } else {\n                // This is creating a native MediaRecorder just to provoke it to throw an error.\n                if (nativeMediaRecorderConstructor !== null) {\n                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                }\n\n                throw createNotSupportedError();\n            }\n\n            this._ondataavailable = null;\n            this._onerror = null;\n            this._onpause = null;\n            this._onresume = null;\n            this._onstart = null;\n            this._onstop = null;\n        }\n\n        get mimeType(): string {\n            return this._internalMediaRecorder.mimeType;\n        }\n\n        get ondataavailable(): null | TBlobEventHandler<this> {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n        }\n\n        set ondataavailable(value) {\n            if (this._ondataavailable !== null) {\n                this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('dataavailable', boundListener);\n\n                this._ondataavailable = [value, boundListener];\n            } else {\n                this._ondataavailable = null;\n            }\n        }\n\n        get onerror(): null | TErrorEventHandler<this> {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n        }\n\n        set onerror(value) {\n            if (this._onerror !== null) {\n                this.removeEventListener('error', this._onerror[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('error', boundListener);\n\n                this._onerror = [value, boundListener];\n            } else {\n                this._onerror = null;\n            }\n        }\n\n        get onpause(): null | TEventHandler<this> {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n        }\n\n        set onpause(value) {\n            if (this._onpause !== null) {\n                this.removeEventListener('pause', this._onpause[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('pause', boundListener);\n\n                this._onpause = [value, boundListener];\n            } else {\n                this._onpause = null;\n            }\n        }\n\n        get onresume(): null | TEventHandler<this> {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n        }\n\n        set onresume(value) {\n            if (this._onresume !== null) {\n                this.removeEventListener('resume', this._onresume[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('resume', boundListener);\n\n                this._onresume = [value, boundListener];\n            } else {\n                this._onresume = null;\n            }\n        }\n\n        get onstart(): null | TEventHandler<this> {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n        }\n\n        set onstart(value) {\n            if (this._onstart !== null) {\n                this.removeEventListener('start', this._onstart[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('start', boundListener);\n\n                this._onstart = [value, boundListener];\n            } else {\n                this._onstart = null;\n            }\n        }\n\n        get onstop(): null | TEventHandler<this> {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n        }\n\n        set onstop(value) {\n            if (this._onstop !== null) {\n                this.removeEventListener('stop', this._onstop[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('stop', boundListener);\n\n                this._onstop = [value, boundListener];\n            } else {\n                this._onstop = null;\n            }\n        }\n\n        get state(): TRecordingState {\n            return this._internalMediaRecorder.state;\n        }\n\n        public pause(): void {\n            return this._internalMediaRecorder.pause();\n        }\n\n        public resume(): void {\n            return this._internalMediaRecorder.resume();\n        }\n\n        public start(timeslice?: number): void {\n            return this._internalMediaRecorder.start(timeslice);\n        }\n\n        public stop(): void {\n            return this._internalMediaRecorder.stop();\n        }\n\n        public static isTypeSupported(mimeType: string): boolean {\n            return (\n                (nativeMediaRecorderConstructor !== null &&\n                    // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||\n                encoderRegexes.some((regex) => regex.test(mimeType))\n            );\n        }\n    };\n};\n", "import { TNativeBlobEventConstructorFactory } from '../types';\n\nexport const createNativeBlobEventConstructor: TNativeBlobEventConstructorFactory = (window) => {\n    if (window !== null && window.BlobEvent !== undefined) {\n        return window.BlobEvent;\n    }\n\n    return null;\n};\n", "import { TNativeMediaRecorderConstructorFactory } from '../types';\n\nexport const createNativeMediaRecorderConstructor: TNativeMediaRecorderConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.MediaRecorder === undefined ? null : window.MediaRecorder;\n};\n", "import { IBlobEvent, IMediaRecorder } from '../interfaces';\nimport { TEventHandler, TNativeMediaRecorderFactoryFactory } from '../types';\n\nexport const createNativeMediaRecorderFactory: TNativeMediaRecorderFactoryFactory =\n    (createNotSupportedError) => (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n        const bufferedBlobEventListeners: Map<EventListener, IBlobEvent[]> = new Map();\n        const dataAvailableListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: IBlobEvent) => void>();\n        const errorListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: ErrorEvent) => void>();\n        const flags: [boolean, boolean][] = [];\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n        const stopListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: Event) => void>();\n\n        nativeMediaRecorder.addEventListener('stop', ({ isTrusted }: Event): void => {\n            if (isTrusted) {\n                setTimeout(() => flags.shift());\n            }\n        });\n\n        nativeMediaRecorder.addEventListener = ((addEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | AddEventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        const bufferedBlobEvents: IBlobEvent[] = [];\n\n                        // Bug #20: Firefox dispatches multiple dataavailable events while being inactive.\n                        patchedEventListener = (event: IBlobEvent) => {\n                            const [[isSliced, isActive] = [false, false]] = flags;\n\n                            if (isSliced && !isActive) {\n                                bufferedBlobEvents.push(event);\n                            } else {\n                                listener.call(nativeMediaRecorder, event);\n                            }\n                        };\n\n                        bufferedBlobEventListeners.set(listener, bufferedBlobEvents);\n                        dataAvailableListeners.set(listener, patchedEventListener);\n                    } else if (type === 'error') {\n                        // Bug #12 & #13: Firefox fires a regular event with an error property.\n                        patchedEventListener = (event: ErrorEvent | (Event & { error?: Error })) => {\n                            if (event instanceof ErrorEvent) {\n                                listener.call(nativeMediaRecorder, event);\n                            } else {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: event.error }));\n                            }\n                        };\n\n                        errorListeners.set(listener, patchedEventListener);\n                    } else if (type === 'stop') {\n                        // Bug #20: Firefox dispatches multiple dataavailable events while being inactive.\n                        patchedEventListener = (event: Event) => {\n                            for (const [dataAvailableListener, bufferedBlobEvents] of bufferedBlobEventListeners.entries()) {\n                                if (bufferedBlobEvents.length > 0) {\n                                    const [blobEvent] = bufferedBlobEvents;\n\n                                    if (bufferedBlobEvents.length > 1) {\n                                        Object.defineProperty(blobEvent, 'data', {\n                                            value: new Blob(\n                                                bufferedBlobEvents.map(({ data }) => data),\n                                                { type: blobEvent.data.type }\n                                            )\n                                        });\n                                    }\n\n                                    bufferedBlobEvents.length = 0;\n\n                                    dataAvailableListener.call(nativeMediaRecorder, blobEvent);\n                                }\n                            }\n\n                            listener.call(nativeMediaRecorder, event);\n                        };\n\n                        stopListeners.set(listener, patchedEventListener);\n                    }\n                }\n\n                return addEventListener.call(nativeMediaRecorder, type, <EventListenerOrEventListenerObject>patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.addEventListener);\n\n        nativeMediaRecorder.removeEventListener = ((removeEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | EventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        bufferedBlobEventListeners.delete(listener);\n\n                        const dataAvailableListener = dataAvailableListeners.get(listener);\n\n                        if (dataAvailableListener !== undefined) {\n                            patchedEventListener = dataAvailableListener;\n                        }\n                    } else if (type === 'error') {\n                        const errorListener = errorListeners.get(listener);\n\n                        if (errorListener !== undefined) {\n                            patchedEventListener = errorListener;\n                        }\n                    } else if (type === 'stop') {\n                        const stopListener = stopListeners.get(listener);\n\n                        if (stopListener !== undefined) {\n                            patchedEventListener = stopListener;\n                        }\n                    }\n                }\n\n                return removeEventListener.call(\n                    nativeMediaRecorder,\n                    type,\n                    <EventListenerOrEventListenerObject>patchedEventListener,\n                    options\n                );\n            };\n        })(nativeMediaRecorder.removeEventListener);\n\n        nativeMediaRecorder.start = ((start) => {\n            return (timeslice?: number) => {\n                /*\n                 * Bug #6: Safari will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (\n                    mediaRecorderOptions.mimeType !== undefined &&\n                    mediaRecorderOptions.mimeType.startsWith('audio/') &&\n                    stream.getVideoTracks().length > 0\n                ) {\n                    throw createNotSupportedError();\n                }\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                    flags.push([timeslice !== undefined, true]);\n                }\n\n                return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n            };\n        })(nativeMediaRecorder.start);\n\n        nativeMediaRecorder.stop = ((stop) => {\n            return () => {\n                if (nativeMediaRecorder.state !== 'inactive') {\n                    flags[0][1] = false;\n                }\n\n                stop.call(nativeMediaRecorder);\n            };\n        })(nativeMediaRecorder.stop);\n\n        return nativeMediaRecorder;\n    };\n", "import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    } catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n\n        return err;\n    }\n};\n", "import { TReadElementContentFactory } from '../types';\n\nexport const createReadElementContent: TReadElementContentFactory = (readVariableSizeInteger) => {\n    return (dataView, offset, type, channelCount = 2) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n\n        const { length, value } = lengthAndValue;\n\n        if (type === 'master') {\n            return { content: null, length };\n        }\n\n        if (offset + length + value > dataView.byteLength) {\n            return null;\n        }\n\n        if (type === 'binary') {\n            const numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n            const content = Array.from({ length: channelCount }, () => new Float32Array(numberOfSamples));\n\n            for (let i = 0; i < numberOfSamples; i += 1) {\n                const elementOffset = i * channelCount + 1;\n\n                for (let j = 0; j < channelCount; j += 1) {\n                    content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n                }\n            }\n\n            return { content, length: length + value };\n        }\n\n        return { content: null, length: length + value };\n    };\n};\n", "import { TReadElementTypeFactory } from '../types';\n\nexport const createReadElementType: TReadElementTypeFactory = (readVariableSizeInteger) => {\n    return (dataView, offset) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n\n        const { length, value } = lengthAndValue;\n\n        if (value === 35) {\n            return { length, type: 'binary' };\n        }\n\n        if (\n            value === 46 ||\n            value === 97 ||\n            value === 88713574 ||\n            value === 106212971 ||\n            value === 139690087 ||\n            value === 172351395 ||\n            value === 256095861\n        ) {\n            return { length, type: 'master' };\n        }\n\n        return { length, type: 'unknown' };\n    };\n};\n", "import { TReadVariableSizeIntegerFactory } from '../types';\n\nexport const createReadVariableSizeInteger: TReadVariableSizeIntegerFactory = (readVariableSizeIntegerLength) => {\n    return (dataView, offset) => {\n        const length = readVariableSizeIntegerLength(dataView, offset);\n\n        if (length === null) {\n            return length;\n        }\n\n        const firstDataByteOffset = offset + Math.floor((length - 1) / 8);\n\n        if (firstDataByteOffset + length > dataView.byteLength) {\n            return null;\n        }\n\n        const firstDataByte = dataView.getUint8(firstDataByteOffset);\n\n        let value = firstDataByte & ((1 << (8 - (length % 8))) - 1); // tslint:disable-line:no-bitwise\n\n        for (let i = 1; i < length; i += 1) {\n            value = (value << 8) + dataView.getUint8(firstDataByteOffset + i); // tslint:disable-line:no-bitwise\n        }\n\n        return { length, value };\n    };\n};\n", "import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { on } from 'subscribable-things';\nimport { isSupported } from 'worker-factory';\nimport { createAddRecorderAudioWorkletModule } from './factories/add-recorder-audio-worklet-module';\nimport { createListener } from './factories/listener';\nimport { createPostMessageFactory } from './factories/post-message-factory';\nimport { createRecorderAudioWorkletNodeFactory } from './factories/recorder-audio-worklet-node-factory';\nimport { validateState } from './functions/validate-state';\nimport { worklet } from './worklet/worklet';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nexport const addRecorderAudioWorkletModule = createAddRecorderAudioWorkletModule(Blob, URL, worklet);\n\nexport const createRecorderAudioWorkletNode = createRecorderAudioWorkletNodeFactory(\n    createListener,\n    createPostMessageFactory(generateUniqueNumber),\n    on,\n    validateState\n);\n\nexport { isSupported };\n", "/**\n * @license Use of this source code is governed by an MIT-style license that\n * can be found in the LICENSE file at https://github.com/cartant/rxjs-interop\n */\n\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol;\n  }\n}\n\nexport const observable = Symbol.observable || \"@@observable\";\n", "/**\n * @license Use of this source code is governed by an MIT-style license that\n * can be found in the LICENSE file at https://github.com/cartant/rxjs-interop\n */\n\nimport { observable } from \"./symbols\";\nimport { InteropObservable } from \"./types\";\n\nexport function patch<T extends InteropObservable<any>>(instance: T): T;\nexport function patch<T extends new (...args: any[]) => InteropObservable<any>>(\n  constructor: T\n): T;\nexport function patch(\n  arg: InteropObservable<any> | (new (...args: any[]) => InteropObservable<any>)\n): InteropObservable<any> | (new (...args: any[]) => InteropObservable<any>) {\n  if (!Symbol.observable) {\n    if (\n      typeof arg === \"function\" &&\n      arg.prototype &&\n      arg.prototype[Symbol.observable]\n    ) {\n      (arg.prototype as any)[observable] = arg.prototype[Symbol.observable];\n      delete arg.prototype[Symbol.observable];\n    } else {\n      (arg as any)[observable] = arg[Symbol.observable];\n      delete arg[Symbol.observable];\n    }\n  }\n  return arg;\n}\n", "/**\n * @license Use of this source code is governed by an MIT-style license that\n * can be found in the LICENSE file at https://github.com/cartant/rxjs-interop\n */\n\nimport { Observer, PartialObserver } from \"./types\";\n\nconst noop = () => {};\nconst rethrow = (error: unknown) => {\n  /* eslint-disable-next-line etc/throw-error */\n  throw error;\n};\n\nexport function toObserver<T>(observer?: PartialObserver<T>): Observer<T> {\n  if (observer) {\n    if (observer.next && observer.error && observer.complete) {\n      return observer as Observer<T>;\n    }\n    return {\n      complete: (observer.complete ?? noop).bind(observer),\n      error: (observer.error ?? rethrow).bind(observer),\n      next: (observer.next ?? noop).bind(observer),\n    };\n  }\n  return {\n    complete: noop,\n    error: rethrow,\n    next: noop,\n  };\n}\n", "import { TAnimationFrameFactory } from '../types';\n\nexport const createAnimationFrame: TAnimationFrameFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return () =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.cancelAnimationFrame === undefined || window.requestAnimationFrame === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            let animationFrameHandle = window.requestAnimationFrame(function animationFrameCallback(timestamp): void {\n                animationFrameHandle = window.requestAnimationFrame(animationFrameCallback);\n\n                observer.next(timestamp);\n            });\n\n            return () => window.cancelAnimationFrame(animationFrameHandle);\n        });\n};\n", "import { TSubscribableThing } from '../types';\nimport type { createMapSubscribableThing } from './map-subscribable-thing';\nimport type { createMutations } from './mutations';\nimport type { createPrependSubscribableThing } from './prepend-subscribable-thing';\n\nexport const createAttribute = (\n    mapSubscribableThing: ReturnType<typeof createMapSubscribableThing>,\n    mutations: ReturnType<typeof createMutations>,\n    prependSubscribableThing: ReturnType<typeof createPrependSubscribableThing>\n) => {\n    return (htmlElement: HTMLElement, name: string): TSubscribableThing<null | string> => {\n        const getAttribute = () => htmlElement.getAttribute(name);\n\n        return prependSubscribableThing(\n            mapSubscribableThing(\n                mutations(htmlElement, {\n                    attributeFilter: [name],\n                    childList: false,\n                    subtree: false\n                }),\n                () => getAttribute()\n            ),\n            getAttribute()\n        );\n    };\n};\n", "import { TEmitNotSupportedErrorFunction, TSubscribableThing, TWindow, TWrapSubscribeFunctionFunction } from '../types';\n\nexport const createGeolocation = (\n    emitNotSupportedError: TEmitNotSupportedErrorFunction,\n    window: null | TWindow,\n    wrapSubscribeFunction: TWrapSubscribeFunctionFunction\n) => {\n    return (options?: PositionOptions): TSubscribableThing<GeolocationPosition> =>\n        wrapSubscribeFunction((observer) => {\n            if (\n                window === null ||\n                window.navigator === undefined ||\n                window.navigator.geolocation === undefined ||\n                window.navigator.geolocation.clearWatch === undefined ||\n                window.navigator.geolocation.watchPosition === undefined\n            ) {\n                return emitNotSupportedError(observer);\n            }\n\n            const watchId = window.navigator.geolocation.watchPosition(\n                (position) => observer.next(position),\n                (err) => observer.error(err),\n                options\n            );\n\n            return () => window.navigator.geolocation.clearWatch(watchId);\n        });\n};\n", "import { TIntersectionsFactory } from '../types';\n\nexport const createIntersections: TIntersectionsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (htmlElement, options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.IntersectionObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const intersectionObserverObserver = new window.IntersectionObserver((entries) => observer.next(entries), options);\n\n            try {\n                intersectionObserverObserver.observe(htmlElement);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => intersectionObserverObserver.disconnect();\n        });\n};\n", "import { TSubscribableThing, TWrapSubscribeFunctionFunction } from '../types';\n\nexport const createMapSubscribableThing =\n    (wrapSubscribeFunction: TWrapSubscribeFunctionFunction) =>\n    <TValue, TMappedValue>(\n        subscribableThing: TSubscribableThing<TValue>,\n        map: (value: TValue) => TMappedValue\n    ): TSubscribableThing<TMappedValue> =>\n        wrapSubscribeFunction((observer) => subscribableThing({ ...observer, next: (value) => observer.next(map(value)) }));\n", "import { TMediaDevicesFactory } from '../types';\n\nexport const createMediaDevices: TMediaDevicesFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return () =>\n        wrapSubscribeFunction((observer) => {\n            if (\n                window === null ||\n                window.navigator === undefined ||\n                window.navigator.mediaDevices === undefined ||\n                window.navigator.mediaDevices.enumerateDevices === undefined\n            ) {\n                return emitNotSupportedError(observer);\n            }\n\n            let isActive = true;\n\n            const enumerateDevices = () => {\n                window.navigator.mediaDevices.enumerateDevices().then(\n                    (mediaDevices) => {\n                        if (isActive) {\n                            observer.next(mediaDevices);\n                        }\n                    },\n                    (err) => {\n                        if (isActive) {\n                            unsubscribe();\n\n                            observer.error(err);\n                        }\n                    }\n                );\n            };\n            const unsubscribe = () => {\n                isActive = false;\n                window.navigator.mediaDevices.removeEventListener('devicechange', enumerateDevices);\n            };\n\n            enumerateDevices();\n            window.navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);\n\n            return unsubscribe;\n        });\n};\n", "import { TMediaQueryMatchFactory } from '../types';\n\nexport const createMediaQueryMatch: TMediaQueryMatchFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (mediaQueryString) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.matchMedia === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const mediaQueryList = window.matchMedia(mediaQueryString);\n\n            observer.next(mediaQueryList.matches);\n\n            mediaQueryList.onchange = () => observer.next(mediaQueryList.matches);\n\n            return () => {\n                mediaQueryList.onchange = null;\n            };\n        });\n};\n", "import { TMetricsFactory } from '../types';\n\nexport const createMetrics: TMetricsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.PerformanceObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const performanceObserver = new window.PerformanceObserver((entryList) => observer.next(entryList.getEntries()));\n\n            try {\n                performanceObserver.observe(options);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => performanceObserver.disconnect();\n        });\n};\n", "import { TMidiInputsFactory } from '../types';\n\nexport const createMidiInputs: TMidiInputsFactory = (wrapSubscribeFunction) => {\n    return (midiAccess) =>\n        wrapSubscribeFunction((observer) => {\n            let midiInputs = Array.from(midiAccess.inputs.values());\n\n            const emitMidiInputs = () => {\n                const midiAccessInputs = midiAccess.inputs;\n\n                if (midiInputs.length !== midiAccessInputs.size || midiInputs.some(({ id }) => !midiAccessInputs.has(id))) {\n                    midiInputs = Array.from(midiAccessInputs.values());\n\n                    observer.next(midiInputs);\n                }\n            };\n\n            observer.next(midiInputs);\n            midiAccess.addEventListener('statechange', emitMidiInputs);\n\n            return () => midiAccess.removeEventListener('statechange', emitMidiInputs);\n        });\n};\n", "import { TMidiOutputsFactory } from '../types';\n\nexport const createMidiOutputs: TMidiOutputsFactory = (wrapSubscribeFunction) => {\n    return (midiAccess) =>\n        wrapSubscribeFunction((observer) => {\n            let midiOutputs = Array.from(midiAccess.outputs.values());\n\n            const emitMidiOutputs = () => {\n                const midiAccessOutputs = midiAccess.outputs;\n\n                if (midiOutputs.length !== midiAccessOutputs.size || midiOutputs.some(({ id }) => !midiAccessOutputs.has(id))) {\n                    midiOutputs = Array.from(midiAccessOutputs.values());\n\n                    observer.next(midiOutputs);\n                }\n            };\n\n            observer.next(midiOutputs);\n            midiAccess.addEventListener('statechange', emitMidiOutputs);\n\n            return () => midiAccess.removeEventListener('statechange', emitMidiOutputs);\n        });\n};\n", "import { TMutationsFactory } from '../types';\n\nexport const createMutations: TMutationsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (htmlElement, options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.MutationObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const mutationObserver = new window.MutationObserver((records) => observer.next(records));\n\n            try {\n                mutationObserver.observe(htmlElement, options);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => mutationObserver.disconnect();\n        });\n};\n", "import { TEventHandler, TEventType, TOnFactory } from '../types';\n\nexport const createOn: TOnFactory = (wrapSubscribeFunction) => {\n    return (target, type, options) =>\n        wrapSubscribeFunction((observer) => {\n            const listener: TEventHandler<typeof target> = (event) => observer.next(<TEventType<typeof target, typeof type>>event);\n\n            target.addEventListener(type, listener, options);\n\n            return () => target.removeEventListener(type, listener, options);\n        });\n};\n", "import { TOnlineFactory } from '../types';\n\nexport const createOnline: TOnlineFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return () =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.navigator === undefined || window.navigator.onLine === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const emitFalse = () => observer.next(false);\n            const emitTrue = () => observer.next(true);\n\n            window.addEventListener('offline', emitFalse);\n            window.addEventListener('online', emitTrue);\n\n            observer.next(window.navigator.onLine);\n\n            return () => {\n                window.removeEventListener('offline', emitFalse);\n                window.removeEventListener('online', emitTrue);\n            };\n        });\n};\n", "import { TPermissionStateFactory } from '../types';\n\nexport const createPermissionState: TPermissionStateFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (permissionDescriptor) =>\n        wrapSubscribeFunction((observer) => {\n            if (\n                window === null ||\n                window.navigator === undefined ||\n                window.navigator.permissions === undefined ||\n                window.navigator.permissions.query === undefined\n            ) {\n                return emitNotSupportedError(observer);\n            }\n\n            let isActive = true;\n            let unsubscribe = () => {\n                isActive = false;\n            };\n\n            window.navigator.permissions.query(permissionDescriptor).then(\n                (permissionStatus) => {\n                    if (isActive) {\n                        observer.next(permissionStatus.state);\n                    }\n\n                    if (isActive) {\n                        permissionStatus.onchange = () => observer.next(permissionStatus.state);\n\n                        unsubscribe = () => {\n                            permissionStatus.onchange = null;\n                        };\n                    }\n                },\n                (err) => {\n                    if (isActive) {\n                        observer.error(err);\n                    }\n                }\n            );\n\n            return () => unsubscribe();\n        });\n};\n", "import { TSubscribableThing, TWrapSubscribeFunctionFunction } from '../types';\n\nexport const createPrependSubscribableThing =\n    (wrapSubscribeFunction: TWrapSubscribeFunctionFunction) =>\n    <TValue, TPrependedValue>(\n        subscribableThing: TSubscribableThing<TValue>,\n        prependedValue: TPrependedValue\n    ): TSubscribableThing<TPrependedValue | TValue> =>\n        wrapSubscribeFunction((observer) => {\n            observer.next(prependedValue);\n\n            return subscribableThing(observer);\n        });\n", "import { TReportsFactory } from '../types';\n\nexport const createReports: TReportsFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.ReportingObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const reportingObserver = new window.ReportingObserver((reportList) => observer.next(reportList), options);\n\n            reportingObserver.observe();\n\n            return () => reportingObserver.disconnect();\n        });\n};\n", "import { IResizeObserverEntry } from '../interfaces';\nimport { TResizesFactory } from '../types';\n\nexport const createResizes: TResizesFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (htmlElement, options) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.ResizeObserver === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const resizeObserver = new window.ResizeObserver((entries) => observer.next(<IResizeObserverEntry[]>entries));\n\n            try {\n                resizeObserver.observe(htmlElement, options);\n            } catch (err) {\n                observer.error(err);\n            }\n\n            return () => resizeObserver.disconnect();\n        });\n};\n", "import { TUnhandledRejectionFactory } from '../types';\n\nexport const createUnhandledRejection: TUnhandledRejectionFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (coolingOffPeriod) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.clearInterval === undefined || window.setInterval === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const possiblyUnhandledRejections = new Map<Promise<any>, { reason: any; timestamp: number }>();\n\n            let intervalId: null | number = null;\n\n            const deletePossiblyUnhandledRejection = ({ promise }: PromiseRejectionEvent) => possiblyUnhandledRejections.delete(promise);\n            const emitUnhandledRejection = () => {\n                const latestTimestampToEmit = Date.now() - coolingOffPeriod;\n\n                possiblyUnhandledRejections.forEach(({ reason, timestamp }, promise) => {\n                    if (timestamp > latestTimestampToEmit) {\n                        return;\n                    }\n\n                    possiblyUnhandledRejections.delete(promise);\n                    observer.next(reason);\n                });\n\n                if (intervalId !== null && possiblyUnhandledRejections.size === 0) {\n                    window.clearInterval(intervalId);\n                    intervalId = null;\n                }\n            };\n            const registerPossiblyUnhandledRejection = (event: PromiseRejectionEvent) => {\n                event.preventDefault();\n\n                possiblyUnhandledRejections.set(event.promise, {\n                    reason: event.reason,\n                    timestamp: Date.now()\n                });\n\n                if (intervalId === null) {\n                    intervalId = window.setInterval(emitUnhandledRejection, coolingOffPeriod / 2);\n                }\n            };\n\n            window.addEventListener('rejectionhandled', deletePossiblyUnhandledRejection);\n            window.addEventListener('unhandledrejection', registerPossiblyUnhandledRejection);\n\n            return () => {\n                if (intervalId !== null) {\n                    window.clearInterval(intervalId);\n                }\n\n                window.removeEventListener('rejectionhandled', deletePossiblyUnhandledRejection);\n                window.removeEventListener('unhandledrejection', registerPossiblyUnhandledRejection);\n            };\n        });\n};\n", "import { TVideoFrameFactory } from '../types';\n\nexport const createVideoFrame: TVideoFrameFactory = (emitNotSupportedError, wrapSubscribeFunction) => {\n    return (videoElement) =>\n        wrapSubscribeFunction((observer) => {\n            if (videoElement.cancelVideoFrameCallback === undefined || videoElement.requestVideoFrameCallback === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            let videoFrameHandle = videoElement.requestVideoFrameCallback(function videoFrameCallback(now, metadata): void {\n                videoFrameHandle = videoElement.requestVideoFrameCallback(videoFrameCallback);\n\n                observer.next({ ...metadata, now });\n            });\n\n            return () => videoElement.cancelVideoFrameCallback(videoFrameHandle);\n        });\n};\n", "import { IWakeLockSentinel } from '../interfaces';\nimport { TWakeLockFactory } from '../types';\n\nexport const createWakeLock: TWakeLockFactory = (emitNotSupportedError, window, wrapSubscribeFunction) => {\n    return (type) =>\n        wrapSubscribeFunction((observer) => {\n            if (window === null || window.navigator === undefined || window.navigator.wakeLock === undefined) {\n                return emitNotSupportedError(observer);\n            }\n\n            const releaseWakeLock = (wakeLockSentinel: IWakeLockSentinel) =>\n                wakeLockSentinel.release().catch(() => {\n                    // Ignore errors.\n                });\n            const removeReleaseEventListener = (wakeLockSentinel: IWakeLockSentinel) => {\n                wakeLockSentinel.onrelease = null;\n            };\n\n            let isActive = true;\n\n            const unsubscribeWhileRequesting = () => {\n                isActive = false;\n            };\n\n            let unsubscribe = unsubscribeWhileRequesting;\n\n            const requestWakeLock = () =>\n                window.navigator.wakeLock.request(type).then(\n                    (wakeLockSentinel) => {\n                        if (isActive) {\n                            observer.next(true);\n                        }\n\n                        if (isActive) {\n                            wakeLockSentinel.onrelease = () => {\n                                observer.next(false);\n\n                                unsubscribe = unsubscribeWhileRequesting;\n\n                                removeReleaseEventListener(wakeLockSentinel);\n                                requestWakeLock();\n                            };\n\n                            unsubscribe = () => {\n                                removeReleaseEventListener(wakeLockSentinel);\n                                releaseWakeLock(wakeLockSentinel);\n                            };\n                        } else {\n                            releaseWakeLock(wakeLockSentinel);\n                        }\n                    },\n                    (err) => {\n                        if (isActive) {\n                            observer.error(err);\n                        }\n                    }\n                );\n\n            requestWakeLock();\n\n            return () => unsubscribe();\n        });\n};\n", "import { TWindow, TWindowFactory } from '../types';\n\n// @todo TypeScript does not include type definitions for the Reporting API yet.\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n", "import { Observer, Subscribable } from 'rxjs-interop';\nimport { TObserverParameters, TSubscribableThing, TSubscribeFunction, TWrapSubscribeFunctionFactory } from '../types';\n\nexport const createWrapSubscribeFunction: TWrapSubscribeFunctionFactory = (patch, toObserver) => {\n    const emptyFunction = () => {}; // tslint:disable-line:no-empty\n    const isNextFunction = <T>(args: TObserverParameters<T>): args is [Observer<T>['next']] => typeof args[0] === 'function';\n\n    return <T>(innerSubscribe: TSubscribeFunction<T>) => {\n        const subscribe = <TSubscribableThing<T>>((...args: TObserverParameters<T>) => {\n            const unsubscribe = innerSubscribe(isNextFunction(args) ? toObserver({ next: args[0] }) : toObserver(...args));\n\n            if (unsubscribe !== undefined) {\n                return unsubscribe;\n            }\n\n            return emptyFunction;\n        });\n\n        subscribe[Symbol.observable] = () => ({\n            subscribe: (...args: Parameters<Subscribable<T>['subscribe']>) => ({ unsubscribe: subscribe(...args) })\n        });\n\n        return patch(subscribe);\n    };\n};\n", "import { TEmitNotSupportedErrorFunction } from '../types';\n\nexport const emitNotSupportedError: TEmitNotSupportedErrorFunction = (observer) => {\n    observer.error(new Error('The required browser API seems to be not supported.'));\n\n    return () => {}; // tslint:disable-line:no-empty\n};\n", "import { patch, toObserver } from 'rxjs-interop';\nimport { createAnimationFrame } from './factories/animation-frame';\nimport { createAttribute } from './factories/attribute';\nimport { createGeolocation } from './factories/geolocation';\nimport { createIntersections } from './factories/intersections';\nimport { createMapSubscribableThing } from './factories/map-subscribable-thing';\nimport { createMediaDevices } from './factories/media-devices';\nimport { createMediaQueryMatch } from './factories/media-query-match';\nimport { createMetrics } from './factories/metrics';\nimport { createMidiInputs } from './factories/midi-inputs';\nimport { createMidiOutputs } from './factories/midi-outputs';\nimport { createMutations } from './factories/mutations';\nimport { createOn } from './factories/on';\nimport { createOnline } from './factories/online';\nimport { createPermissionState } from './factories/permission-state';\nimport { createPrependSubscribableThing } from './factories/prepend-subscribable-thing';\nimport { createReports } from './factories/reports';\nimport { createResizes } from './factories/resizes';\nimport { createUnhandledRejection } from './factories/unhandled-rejection';\nimport { createVideoFrame } from './factories/video-frame';\nimport { createWakeLock } from './factories/wake-lock';\nimport { createWindow } from './factories/window';\nimport { createWrapSubscribeFunction } from './factories/wrap-subscribe-function';\nimport { emitNotSupportedError } from './functions/emit-not-supported-error';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst window = createWindow();\nconst wrapSubscribeFunction = createWrapSubscribeFunction(patch, toObserver);\n\nexport const animationFrame = createAnimationFrame(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const mutations = createMutations(emitNotSupportedError, window, wrapSubscribeFunction);\n\nconst mapSubscribableThing = createMapSubscribableThing(wrapSubscribeFunction);\nconst prependSubscribableThing = createPrependSubscribableThing(wrapSubscribeFunction);\n\nexport const attribute = createAttribute(mapSubscribableThing, mutations, prependSubscribableThing);\n\nexport const geolocation = createGeolocation(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const intersections = createIntersections(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const mediaDevices = createMediaDevices(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const mediaQueryMatch = createMediaQueryMatch(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const metrics = createMetrics(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const midiInputs = createMidiInputs(wrapSubscribeFunction);\n\nexport const midiOutputs = createMidiOutputs(wrapSubscribeFunction);\n\nexport const on = createOn(wrapSubscribeFunction);\n\nexport const online = createOnline(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const permissionState = createPermissionState(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const reports = createReports(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const resizes = createResizes(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const unhandledRejection = createUnhandledRejection(emitNotSupportedError, window, wrapSubscribeFunction);\n\nexport const videoFrame = createVideoFrame(emitNotSupportedError, wrapSubscribeFunction);\n\nexport const wakeLock = createWakeLock(emitNotSupportedError, window, wrapSubscribeFunction);\n", "import { IAugmentedError, IParameterObject, compile } from 'compilerr';\n\nconst JSON_RPC_ERROR_CODES = { INTERNAL_ERROR: -32603, INVALID_PARAMS: -32602, METHOD_NOT_FOUND: -32601 };\n\nexport const renderMethodNotFoundError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The requested method called \"${method}\" is not supported.',\n    status: JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND\n});\n\nexport const renderMissingResponseError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The handler of the method called \"${method}\" returned no required result.',\n    status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR\n});\n\nexport const renderUnexpectedResultError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The handler of the method called \"${method}\" returned an unexpected result.',\n    status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR\n});\n\nexport const renderUnknownPortIdError: (missingParameters: IParameterObject) => IAugmentedError = compile({\n    message: 'The specified parameter called \"portId\" with the given value \"${portId}\" does not identify a port connected to this worker.',\n    status: JSON_RPC_ERROR_CODES.INVALID_PARAMS\n});\n", "import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { IDefaultWorkerDefinition, IReceiver, IWorkerDefinition } from '../interfaces';\nimport { TDestroyWorkerFunction, TWorkerImplementation } from '../types';\nimport { renderUnknownPortIdError } from './error-renderers';\nimport { isSupportingTransferables } from './is-supporting-transferables';\n\nconst DESTROY_WORKER_FUNCTIONS: Map<number, TDestroyWorkerFunction> = new Map();\n\nexport const extendWorkerImplementation = <T extends IWorkerDefinition>(\n    createWorker: (receiver: IReceiver, workerImplementation: TWorkerImplementation<T>) => TDestroyWorkerFunction,\n    partialWorkerImplementation: TWorkerImplementation<T>,\n    isSupportedFunction: () => boolean | Promise<boolean>\n): TWorkerImplementation<T> & TWorkerImplementation<IDefaultWorkerDefinition> => ({\n    ...partialWorkerImplementation,\n    connect: ({ port }) => {\n        port.start();\n\n        const destroyWorker = createWorker(port, partialWorkerImplementation);\n        const portId = generateUniqueNumber(DESTROY_WORKER_FUNCTIONS);\n\n        DESTROY_WORKER_FUNCTIONS.set(portId, () => {\n            destroyWorker();\n            port.close();\n            DESTROY_WORKER_FUNCTIONS.delete(portId);\n        });\n\n        return { result: portId };\n    },\n    disconnect: ({ portId }) => {\n        const destroyWorker = DESTROY_WORKER_FUNCTIONS.get(portId);\n\n        if (destroyWorker === undefined) {\n            throw renderUnknownPortIdError({ portId: portId.toString() });\n        }\n\n        destroyWorker();\n\n        return { result: null };\n    },\n    isSupported: async () => {\n        const isSelfSupported = await isSupportingTransferables();\n\n        if (isSelfSupported) {\n            const result = isSupportedFunction();\n            const synchronousResult = result instanceof Promise ? await result : result;\n\n            return { result: synchronousResult };\n        }\n\n        return { result: false };\n    }\n});\n", "export const createAddRecorderAudioWorkletModule = (blobConstructor: typeof Blob, urlConstructor: typeof URL, worklet: string) => {\n    return async (addAudioWorkletModule: (url: string) => Promise<void>) => {\n        const blob = new blobConstructor([worklet], { type: 'application/javascript; charset=utf-8' });\n        const url = urlConstructor.createObjectURL(blob);\n\n        try {\n            await addAudioWorkletModule(url);\n        } finally {\n            urlConstructor.revokeObjectURL(url);\n        }\n    };\n};\n", "import type { IWorkerEvent } from 'broker-factory';\nimport type { IWorkerErrorMessage, IWorkerResultMessage } from 'worker-factory';\n\nexport const createListener = (ongoingRequests: Map<number, { reject: Function; resolve: Function }>) => {\n    return ({ data: message }: IWorkerEvent) => {\n        const { id } = message;\n\n        if (id !== null) {\n            const ongoingRequest = ongoingRequests.get(id);\n\n            if (ongoingRequest !== undefined) {\n                const { reject, resolve } = ongoingRequest;\n\n                ongoingRequests.delete(id);\n\n                if ((<IWorkerErrorMessage>message).error === undefined) {\n                    resolve((<IWorkerResultMessage>message).result);\n                } else {\n                    reject(new Error((<IWorkerErrorMessage>message).error.message));\n                }\n            }\n        }\n    };\n};\n", "import type { generateUniqueNumber as generateUniqueNumberFunction } from 'fast-unique-numbers';\n\nexport const createPostMessageFactory = (generateUniqueNumber: typeof generateUniqueNumberFunction) => {\n    return (ongoingRequests: Map<number, { reject: Function; resolve: Function }>, port: MessagePort) => {\n        return (message: { method: string; params?: object }, transferables: Transferable[] = []): Promise<void> => {\n            return new Promise((resolve, reject) => {\n                const id = generateUniqueNumber(ongoingRequests);\n\n                ongoingRequests.set(id, { reject, resolve });\n\n                port.postMessage({ id, ...message }, transferables);\n            });\n        };\n    };\n};\n", "import type {\n    IAudioWorkletNode,\n    TAudioWorkletNodeConstructor,\n    TContext,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeConstructor,\n    TNativeContext\n} from 'standardized-audio-context';\nimport type { on as onFunction } from 'subscribable-things';\nimport type { validateState as validateStateFunction } from '../functions/validate-state';\nimport { INativeRecorderAudioWorkletNode, IRecorderAudioWorkletNode } from '../interfaces';\nimport { TAnyRecorderAudioWorkletNodeOptions, TState } from '../types';\nimport type { createListener as createListenerFunction } from './listener';\nimport type { createPostMessageFactory } from './post-message-factory';\n\nexport const createRecorderAudioWorkletNodeFactory = (\n    createListener: typeof createListenerFunction,\n    createPostMessage: ReturnType<typeof createPostMessageFactory>,\n    on: typeof onFunction,\n    validateState: typeof validateStateFunction\n) => {\n    return <T extends TContext | TNativeContext>(\n        audioWorkletNodeConstructor: T extends TContext ? TAudioWorkletNodeConstructor : TNativeAudioWorkletNodeConstructor,\n        context: T,\n        options: Partial<TAnyRecorderAudioWorkletNodeOptions<T>> = {}\n    ): T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode => {\n        type TAnyAudioWorkletNode = T extends TContext ? IAudioWorkletNode<T> : TNativeAudioWorkletNode;\n        type TAnyRecorderAudioWorkletNode = T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode;\n\n        const audioWorkletNode: TAnyAudioWorkletNode = new (<any>audioWorkletNodeConstructor)(context, 'recorder-audio-worklet-processor', {\n            ...options,\n            channelCountMode: 'explicit',\n            numberOfInputs: 1,\n            numberOfOutputs: 0\n        });\n        const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n\n        audioWorkletNode.port.start();\n\n        let state: TState = 'inactive';\n\n        Object.defineProperties(audioWorkletNode, {\n            pause: {\n                get(): TAnyRecorderAudioWorkletNode['pause'] {\n                    return async () => {\n                        validateState(['recording'], state);\n\n                        state = 'paused';\n\n                        return postMessage({\n                            method: 'pause'\n                        });\n                    };\n                }\n            },\n            port: {\n                get(): TAnyRecorderAudioWorkletNode['port'] {\n                    throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n                }\n            },\n            record: {\n                get(): TAnyRecorderAudioWorkletNode['record'] {\n                    return async (encoderPort: MessagePort) => {\n                        validateState(['inactive'], state);\n\n                        state = 'recording';\n\n                        return postMessage(\n                            {\n                                method: 'record',\n                                params: { encoderPort }\n                            },\n                            [encoderPort]\n                        );\n                    };\n                }\n            },\n            resume: {\n                get(): TAnyRecorderAudioWorkletNode['resume'] {\n                    return async () => {\n                        validateState(['paused'], state);\n\n                        state = 'recording';\n\n                        return postMessage({\n                            method: 'resume'\n                        });\n                    };\n                }\n            },\n            stop: {\n                get(): TAnyRecorderAudioWorkletNode['stop'] {\n                    return async () => {\n                        validateState(['paused', 'recording'], state);\n\n                        state = 'stopped';\n\n                        try {\n                            await postMessage({ method: 'stop' });\n                        } finally {\n                            unsubscribe();\n                        }\n                    };\n                }\n            }\n        });\n\n        return <TAnyRecorderAudioWorkletNode>audioWorkletNode;\n    };\n};\n", "import { TState } from '../types';\n\nexport const validateState = (expectedStates: TState[], currentState: TState): void => {\n    if (!expectedStates.includes(currentState)) {\n        throw new Error(\n            `Expected the state to be ${expectedStates\n                .map((expectedState) => `\"${expectedState}\"`)\n                .join(' or ')} but it was \"${currentState}\".`\n        );\n    }\n};\n", "// This is the minified and stringified code of the recorder-audio-worklet-processor package.\nexport const worklet = `(()=>{\"use strict\";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._numberOfChannels=0,this._state=\"inactive\",this.port.onmessage=e=>{let{data:t}=e;\"pause\"===t.method?\"active\"===this._state||\"recording\"===this._state?(this._state=\"paused\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"record\"===t.method?\"inactive\"===this._state?(this._encoderPort=t.params.encoderPort,this._state=\"active\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"resume\"===t.method?\"paused\"===this._state?(this._state=\"active\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"stop\"===t.method?\"active\"!==this._state&&\"paused\"!==this._state&&\"recording\"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(t.id):(this._stop(this._encoderPort),this._sendAcknowledgement(t.id)):\"number\"==typeof t.id&&this.port.postMessage({error:{code:-32601,message:\"The requested method is not supported.\"},id:t.id})}}process(e){let[t]=e;if(\"inactive\"===this._state||\"paused\"===this._state)return!0;if(\"active\"===this._state){if(void 0===t)throw new Error(\"No channelData was received for the first input.\");if(0===t.length)return!0;this._state=\"recording\"}if(\"recording\"===this._state&&null!==this._encoderPort){if(void 0===t)throw new Error(\"No channelData was received for the first input.\");return 0===t.length?this._encoderPort.postMessage(Array.from({length:this._numberOfChannels},(()=>128))):(this._encoderPort.postMessage(t,t.map((e=>{let{buffer:t}=e;return t}))),this._numberOfChannels=t.length),!0}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:\"The internal state does not allow to process the given message.\"},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state=\"stopped\"}}e.parameterDescriptors=[],registerProcessor(\"recorder-audio-worklet-processor\",e)})();`; // tslint:disable-line:max-line-length\n", "import {\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent\n} from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport {\n    AUDIO_NODE_CONNECTIONS_STORE,\n    AUDIO_NODE_STORE,\n    AUDIO_PARAM_CONNECTIONS_STORE,\n    AUDIO_PARAM_STORE,\n    CONTEXT_STORE,\n    CYCLE_COUNTERS\n} from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\nimport {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioContext,\n    IAudioNode,\n    IAudioWorkletNode,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IOfflineAudioContextConstructor,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IStereoPannerNode,\n    IWaveShaperNode\n} from './interfaces';\nimport {\n    TActiveAudioWorkletNodeInputsStore,\n    TAddAudioWorkletModuleFunction,\n    TAnalyserNodeConstructor,\n    TAudioBufferConstructor,\n    TAudioBufferSourceNodeConstructor,\n    TAudioBufferStore,\n    TAudioContextConstructor,\n    TAudioParamAudioNodeStore,\n    TAudioWorkletNodeConstructor,\n    TBackupOfflineAudioContextStore,\n    TBiquadFilterNodeConstructor,\n    TChannelMergerNodeConstructor,\n    TChannelSplitterNodeConstructor,\n    TConstantSourceNodeConstructor,\n    TContext,\n    TConvolverNodeConstructor,\n    TDecodeAudioDataFunction,\n    TDelayNodeConstructor,\n    TDynamicsCompressorNodeConstructor,\n    TGainNodeConstructor,\n    TIIRFilterNodeConstructor,\n    TMediaElementAudioSourceNodeConstructor,\n    TMediaStreamAudioDestinationNodeConstructor,\n    TMediaStreamAudioSourceNodeConstructor,\n    TMediaStreamTrackAudioSourceNodeConstructor,\n    TMinimalAudioContextConstructor,\n    TMinimalOfflineAudioContextConstructor,\n    TOscillatorNodeConstructor,\n    TPannerNodeConstructor,\n    TPeriodicWaveConstructor,\n    TStereoPannerNodeConstructor,\n    TUnrenderedAudioWorkletNodeStore,\n    TWaveShaperNodeConstructor\n} from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore: TAudioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(\n    createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),\n    createAddConnectionToAudioNode(\n        addActiveInputConnectionToAudioNode,\n        addPassiveInputConnectionToAudioNode,\n        connectNativeAudioNodeToNativeAudioNode,\n        deleteActiveInputConnectionToAudioNode,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getAudioNodeTailTime,\n        getEventListenersOfAudioNode,\n        getNativeAudioNode,\n        insertElementInSet,\n        isActiveAudioNode,\n        isPartOfACycle,\n        isPassiveAudioNode\n    ),\n    cacheTestResult,\n    createIncrementCycleCounterFactory(\n        CYCLE_COUNTERS,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        isActiveAudioNode\n    ),\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    createDecrementCycleCounter(\n        connectNativeAudioNodeToNativeAudioNode,\n        CYCLE_COUNTERS,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        getNativeContext,\n        isActiveAudioNode,\n        isNativeOfflineAudioContext\n    ),\n    createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey),\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n);\nconst analyserNodeConstructor: TAnalyserNodeConstructor = createAnalyserNodeConstructor(\n    audioNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\n\ntype analyserNodeConstructor<T extends TContext> = IAnalyserNode<T>;\n\nexport { analyserNodeConstructor as AnalyserNode };\n\nconst audioBufferStore: TAudioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor: TAudioBufferConstructor = createAudioBufferConstructor(\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\ntype audioBufferConstructor = IAudioBuffer;\n\nexport { audioBufferConstructor as AudioBuffer };\n\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClamping,\n    createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst createAudioParam = createAudioParamFactory(\n    createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),\n    audioParamAudioNodeStore,\n    AUDIO_PARAM_STORE,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n);\nconst audioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\n\ntype audioBufferSourceNodeConstructor<T extends TContext> = IAudioBufferSourceNode<T>;\n\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\n\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors),\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor: TBiquadFilterNodeConstructor = createBiquadFilterNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelMergerNodeConstructor: TChannelMergerNodeConstructor = createChannelMergerNodeConstructor(\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelSplitterNodeConstructor: TChannelSplitterNodeConstructor = createChannelSplitterNodeConstructor(\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst constantSourceNodeConstructor: TConstantSourceNodeConstructor = createConstantSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRenderer,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst convolverNodeConstructor: TConvolverNodeConstructor = createConvolverNodeConstructor(\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst delayNodeConstructor: TDelayNodeConstructor = createDelayNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst dynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createGainNodeRenderer = createGainNodeRendererFactory(\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst gainNodeConstructor: TGainNodeConstructor = createGainNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor)\n);\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor: TIIRFilterNodeConstructor = createIIRFilterNodeConstructor(\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createAudioListener = createAudioListenerFactory(\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n);\nconst unrenderedAudioWorkletNodeStore: TUnrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst oscillatorNodeConstructor: TOscillatorNodeConstructor = createOscillatorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst pannerNodeConstructor: TPannerNodeConstructor = createPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor: TPeriodicWaveConstructor = createPeriodicWaveConstructor(\n    createNativePeriodicWave,\n    getNativeContext,\n    new WeakSet(),\n    sanitizePeriodicWaveOptions\n);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst stereoPannerNodeConstructor: TStereoPannerNodeConstructor = createStereoPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst waveShaperNodeConstructor: TWaveShaperNodeConstructor = createWaveShaperNodeConstructor(\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore: TBackupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n);\n\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule: undefined | TAddAudioWorkletModuleFunction = isSecureContext\n    ? createAddAudioWorkletModule(\n          cacheTestResult,\n          createNotSupportedError,\n          createEvaluateSource(window),\n          exposeCurrentFrameAndCurrentTime,\n          createFetchSource(createAbortError),\n          getNativeContext,\n          getOrCreateBackupOfflineAudioContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          new WeakMap(),\n          new WeakMap(),\n          createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n          // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n          <NonNullable<typeof window>>window\n      )\n    : undefined;\n\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n\nexport const decodeAudioData: TDecodeAudioDataFunction = createDecodeAudioData(\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    new WeakSet(),\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n);\nconst mediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructor =\n    createMediaStreamAudioDestinationNodeConstructor(\n        audioNodeConstructor,\n        createNativeMediaStreamAudioDestinationNode,\n        getNativeContext,\n        isNativeOfflineAudioContext\n    );\nconst mediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructor =\n    createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor: TAudioContextConstructor = createAudioContextConstructor(\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n);\n\ntype audioContextConstructor = IAudioContext;\n\nexport { audioContextConstructor as AudioContext };\n\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore: TActiveAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor: undefined | TAudioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(\n          addUnrenderedAudioWorkletNode,\n          audioNodeConstructor,\n          createAudioParam,\n          createAudioWorkletNodeRenderer,\n          createNativeAudioWorkletNode,\n          getAudioNodeConnections,\n          getBackupOfflineAudioContext,\n          getNativeContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          sanitizeAudioWorkletNodeOptions,\n          setActiveAudioWorkletNodeInputs,\n          testAudioWorkletNodeOptionsClonability,\n          wrapEventListener\n      )\n    : undefined;\n\ntype audioWorkletNodeConstructor<T extends TContext> = undefined | IAudioWorkletNode<T>;\n\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\n\ntype biquadFilterNodeConstructor<T extends TContext> = IBiquadFilterNode<T>;\n\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\n\ntype channelMergerNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelMergerNodeConstructor as ChannelMergerNode };\n\ntype channelSplitterNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\n\ntype constantSourceNodeConstructor<T extends TContext> = IConstantSourceNode<T>;\n\nexport { convolverNodeConstructor as ConvolverNode };\n\ntype convolverNodeConstructor<T extends TContext> = IConvolverNode<T>;\n\nexport { constantSourceNodeConstructor as ConstantSourceNode };\n\ntype delayNodeConstructor<T extends TContext> = IDelayNode<T>;\n\nexport { delayNodeConstructor as DelayNode };\n\ntype dynamicsCompressorNodeConstructor<T extends TContext> = IDynamicsCompressorNode<T>;\n\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\n\ntype gainNodeConstructor<T extends TContext> = IGainNode<T>;\n\nexport { gainNodeConstructor as GainNode };\n\ntype iIRFilterNodeConstructor<T extends TContext> = IIIRFilterNode<T>;\n\nexport { iIRFilterNodeConstructor as IIRFilterNode };\n\ntype mediaElementAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaElementAudioSourceNode<T>;\n\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\n\ntype mediaStreamAudioDestinationNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioDestinationNode<T>;\n\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\n\ntype mediaStreamAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioSourceNode<T>;\n\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\n\ntype mediaStreamTrackAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamTrackAudioSourceNode<T>;\n\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\n\nconst minimalAudioContextConstructor: TMinimalAudioContextConstructor = createMinimalAudioContextConstructor(\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n);\n\ntype minimalAudioContextConstructor = IMinimalAudioContext;\n\nexport { minimalAudioContextConstructor as MinimalAudioContext };\n\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n);\nconst startRendering = createStartRendering(\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\nconst minimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n);\n\ntype minimalOfflineAudioContextConstructor = IMinimalOfflineAudioContext;\n\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\n\nconst offlineAudioContextConstructor: IOfflineAudioContextConstructor = createOfflineAudioContextConstructor(\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n);\n\ntype offlineAudioContextConstructor = IOfflineAudioContext;\n\nexport { offlineAudioContextConstructor as OfflineAudioContext };\n\ntype oscillatorNodeConstructor<T extends TContext> = IOscillatorNode<T>;\n\nexport { oscillatorNodeConstructor as OscillatorNode };\n\ntype pannerNodeConstructor<T extends TContext> = IPannerNode<T>;\n\nexport { pannerNodeConstructor as PannerNode };\n\ntype periodicWaveConstructor = IPeriodicWave;\n\nexport { periodicWaveConstructor as PeriodicWave };\n\ntype stereoPannerNodeConstructor<T extends TContext> = IStereoPannerNode<T>;\n\nexport { stereoPannerNodeConstructor as StereoPannerNode };\n\ntype waveShaperNodeConstructor<T extends TContext> = IWaveShaperNode<T>;\n\nexport { waveShaperNodeConstructor as WaveShaperNode };\n\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n\nexport const isSupported = () =>\n    createIsSupportedPromise(\n        cacheTestResult,\n        createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor),\n        createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextOptionsSupport(nativeAudioContextConstructor),\n        createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n        createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        testDomExceptionConstructorSupport,\n        createTestIsSecureContextSupport(window),\n        createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor),\n        createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor),\n        testTransferablesSupport\n    );\n", "import { TAbortErrorFactory } from '../types';\n\nexport const createAbortError: TAbortErrorFactory = () => new DOMException('', 'AbortError');\n", "import { TAddActiveInputConnectionToAudioNodeFactory } from '../types/add-active-input-connection-to-audio-node-factory';\n\nexport const createAddActiveInputConnectionToAudioNode: TAddActiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(\n            activeInputs[input],\n            [source, output, eventListener],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n            ignoreDuplicates\n        );\n    };\n};\n", "import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TActiveInputConnection, TAddAudioNodeConnectionsFactory, TContext, TNativeAudioNode } from '../types';\n\nexport const createAddAudioNodeConnections: TAddAudioNodeConnectionsFactory = (audioNodeConnectionsStore) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null,\n        nativeAudioNode: TNativeAudioNode\n    ) => {\n        const activeInputs = [];\n\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set<TActiveInputConnection<T>>());\n        }\n\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n", "import { IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAddAudioParamConnectionsFactory, TContext } from '../types';\n\nexport const createAddAudioParamConnections: TAddAudioParamConnectionsFactory = (audioParamConnectionsStore) => {\n    return <T extends TContext>(\n        audioParam: IAudioParam,\n        audioParamRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null\n    ) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n", "import { IAudioNode, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from './interfaces';\nimport {\n    TAudioNodeConnectionsStore,\n    TAudioNodeStore,\n    TAudioParamConnectionsStore,\n    TAudioParamStore,\n    TContext,\n    TContextStore,\n    TCycleCounters,\n    TInternalStateEventListener,\n    TNativeAudioWorkletNode,\n    TNativeContext\n} from './types';\n\nexport const ACTIVE_AUDIO_NODE_STORE: WeakSet<IAudioNode<TContext>> = new WeakSet();\n\nexport const AUDIO_NODE_CONNECTIONS_STORE: TAudioNodeConnectionsStore = new WeakMap();\n\nexport const AUDIO_NODE_STORE: TAudioNodeStore = new WeakMap();\n\nexport const AUDIO_PARAM_CONNECTIONS_STORE: TAudioParamConnectionsStore = new WeakMap();\n\nexport const AUDIO_PARAM_STORE: TAudioParamStore = new WeakMap();\n\nexport const CONTEXT_STORE: TContextStore = new WeakMap();\n\nexport const EVENT_LISTENERS: WeakMap<IAudioNode<TContext>, Set<TInternalStateEventListener>> = new WeakMap();\n\nexport const CYCLE_COUNTERS: TCycleCounters = new WeakMap();\n\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS: WeakMap<\n    TNativeContext,\n    Map<string, IAudioWorkletProcessorConstructor>\n> = new WeakMap();\n\nexport const NODE_TO_PROCESSOR_MAPS: WeakMap<\n    TNativeContext,\n    WeakMap<TNativeAudioWorkletNode, Promise<IAudioWorkletProcessor>>\n> = new WeakMap();\n", "import { TConstructor } from '../types';\n\nconst handler = {\n    construct(): any {\n        return handler;\n    }\n};\n\nexport const isConstructible = (constructible: TConstructor): boolean => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n\n        new proxy(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source: string, url: string): [string, string] => {\n    const importStatements = [];\n\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n", "import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nimport { IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TAddAudioWorkletModuleFactory, TEvaluateAudioWorkletGlobalScopeFunction } from '../types';\n\nconst verifyParameterDescriptors = (parameterDescriptors: IAudioWorkletProcessorConstructor['parameterDescriptors']) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\n\nconst verifyProcessorCtor = <T extends IAudioWorkletProcessorConstructor>(processorCtor: T) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\n\nexport const createAddAudioWorkletModule: TAddAudioWorkletModuleFactory = (\n    cacheTestResult,\n    createNotSupportedError,\n    evaluateSource,\n    exposeCurrentFrameAndCurrentTime,\n    fetchSource,\n    getNativeContext,\n    getOrCreateBackupOfflineAudioContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    ongoingRequests,\n    resolvedRequests,\n    testAudioWorkletProcessorPostMessageSupport,\n    window\n) => {\n    let index = 0;\n\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n\n        const nativeContext = getNativeContext(context);\n\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise =\n            nativeContext.audioWorklet === undefined\n                ? fetchSource(moduleURL)\n                      .then(([source, absoluteUrl]) => {\n                          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n\n                          /*\n                           * This is the unminified version of the code used below:\n                           *\n                           * ```js\n                           * ${ importStatements };\n                           * ((a, b) => {\n                           *     (a[b] = a[b] || [ ]).push(\n                           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                           *             ${ sourceWithoutImportStatements }\n                           *         }\n                           *     );\n                           * })(window, '_AWGS');\n                           * ```\n                           */\n                          // tslint:disable-next-line:max-line-length\n                          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n\n                          // @todo Evaluating the given source code is a possible security problem.\n                          return evaluateSource(wrappedSource);\n                      })\n                      .then(() => {\n                          const evaluateAudioWorkletGlobalScope = (<TEvaluateAudioWorkletGlobalScopeFunction[]>(<any>window)._AWGS).pop();\n\n                          if (evaluateAudioWorkletGlobalScope === undefined) {\n                              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                              throw new SyntaxError();\n                          }\n\n                          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                              evaluateAudioWorkletGlobalScope(\n                                  class AudioWorkletProcessor {},\n                                  undefined,\n                                  (name, processorCtor) => {\n                                      if (name.trim() === '') {\n                                          throw createNotSupportedError();\n                                      }\n\n                                      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n                                      if (nodeNameToProcessorConstructorMap !== undefined) {\n                                          if (nodeNameToProcessorConstructorMap.has(name)) {\n                                              throw createNotSupportedError();\n                                          }\n\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                                      } else {\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                                      }\n                                  },\n                                  nativeContext.sampleRate,\n                                  undefined,\n                                  undefined\n                              )\n                          );\n                      })\n                : Promise.all([\n                      fetchSource(moduleURL),\n                      Promise.resolve(\n                          cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport)\n                      )\n                  ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                      const currentIndex = index + 1;\n\n                      index = currentIndex;\n\n                      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                      /*\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * This is the unminified version of the code used below.\n                       *\n                       * ```js\n                       * class extends AudioWorkletProcessor {\n                       *\n                       *     __buffers = new WeakSet();\n                       *\n                       *     constructor () {\n                       *         super();\n                       *\n                       *         this.port.postMessage = ((postMessage) => {\n                       *             return (message, transferables) => {\n                       *                 const filteredTransferables = (transferables)\n                       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                       *                     : transferables;\n                       *\n                       *                 return postMessage.call(this.port, message, filteredTransferables);\n                       *              };\n                       *         })(this.port.postMessage);\n                       *     }\n                       * }\n                       * ```\n                       */\n                      const patchedAudioWorkletProcessor = isSupportingPostMessage\n                          ? 'AudioWorkletProcessor'\n                          : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                      /*\n                       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                       *\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                       *\n                       * This is the unminified version of the code used below:\n                       *\n                       * ```js\n                       * `${ importStatements };\n                       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                       * })(\n                       *     ${\u00A0patchedAudioWorkletProcessor },\n                       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                       *\n                       *         __collectBuffers = (array) => {\n                       *             array.forEach((element) => this.__buffers.add(element.buffer));\n                       *         };\n                       *\n                       *         process (inputs, outputs, parameters) {\n                       *             inputs.forEach(this.__collectBuffers);\n                       *             outputs.forEach(this.__collectBuffers);\n                       *             this.__collectBuffers(Object.values(parameters));\n                       *\n                       *             return super.process(\n                       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                       *                 outputs,\n                       *                 parameters\n                       *             );\n                       *         }\n                       *\n                       *     })\n                       * );\n                       *\n                       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                       *\n                       *     process () {\n                       *         return false;\n                       *     }\n                       *\n                       * })`\n                       * ```\n                       */\n                      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                      const bufferRegistration = isSupportingPostMessage\n                          ? ''\n                          : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                      const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                      const url = URL.createObjectURL(blob);\n\n                      return nativeContext.audioWorklet\n                          .addModule(url, options)\n                          .then(() => {\n                              if (isNativeOfflineAudioContext(nativeContext)) {\n                                  return nativeContext;\n                              }\n\n                              // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                              const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n\n                              return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                          })\n                          .then((nativeContextOrBackupOfflineAudioContext) => {\n                              if (nativeAudioWorkletNodeConstructor === null) {\n                                  throw new SyntaxError();\n                              }\n\n                              try {\n                                  // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                                  new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                              } catch {\n                                  throw new SyntaxError();\n                              }\n                          })\n                          .finally(() => URL.revokeObjectURL(url));\n                  });\n\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n\n        promise\n            .then(() => {\n                const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n                if (updatedResolvedRequestsOfContext === undefined) {\n                    resolvedRequests.set(context, new Set([moduleURL]));\n                } else {\n                    updatedResolvedRequestsOfContext.add(moduleURL);\n                }\n            })\n            .finally(() => {\n                const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n                if (updatedOngoingRequestsOfContext !== undefined) {\n                    updatedOngoingRequestsOfContext.delete(moduleURL);\n                }\n            });\n\n        return promise;\n    };\n};\n", "import { TGetValueForKeyFunction } from '../types';\n\nexport const getValueForKey: TGetValueForKeyFunction = (map, key) => {\n    const value = map.get(key);\n\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n\n    return value;\n};\n", "import { TPickElementFromSetFunction } from '../types';\n\nexport const pickElementFromSet: TPickElementFromSetFunction = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n\n    const [matchingElement] = matchingElements;\n\n    set.delete(matchingElement);\n\n    return matchingElement;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioNodeInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioNode = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioNodeInputConnection>>,\n    source: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n", "import { EVENT_LISTENERS } from '../globals';\nimport { TGetEventListenersOfAudioNodeFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getEventListenersOfAudioNode: TGetEventListenersOfAudioNodeFunction = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToActive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n", "import { IAudioNode, IAudioWorkletNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioWorkletNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioWorkletNode<T> => {\n    return 'port' in audioNode;\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToPassive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n", "import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    activeInputs: Set<TActiveInputConnection<T>>[]\n) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n", "import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { IAudioNode } from '../interfaces';\nimport { TAddConnectionToAudioNodeFactory, TContext, TInternalStateEventListener } from '../types';\n\nexport const createAddConnectionToAudioNode: TAddConnectionToAudioNodeFactory = (\n    addActiveInputConnectionToAudioNode,\n    addPassiveInputConnectionToAudioNode,\n    connectNativeAudioNodeToNativeAudioNode,\n    deleteActiveInputConnectionToAudioNode,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getAudioNodeTailTime,\n    getEventListenersOfAudioNode,\n    getNativeAudioNode,\n    insertElementInSet,\n    isActiveAudioNode,\n    isPartOfACycle,\n    isPassiveAudioNode\n) => {\n    const tailTimeTimeoutIds = new WeakMap<IAudioNode<TContext>, number>();\n\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n\n        const eventListener: TInternalStateEventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            } else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                const tailTime = getAudioNodeTailTime(destination);\n\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                } else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n\n                    tailTimeTimeoutIds.set(\n                        destination,\n                        setTimeout(() => {\n                            if (isActiveAudioNode(destination)) {\n                                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                            }\n                        }, tailTime * 1000)\n                    );\n                }\n            }\n        };\n\n        if (\n            insertElementInSet(\n                outputs,\n                [destination, output, input],\n                (outputConnection) =>\n                    outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input,\n                true\n            )\n        ) {\n            eventListeners.add(eventListener);\n\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            } else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n};\n", "import { TAddPassiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createAddPassiveInputConnectionToAudioNode: TAddPassiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n            insertElementInSet(\n                passiveInputConnections,\n                [output, input, eventListener],\n                (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input,\n                ignoreDuplicates\n            );\n        }\n    };\n};\n", "import { TAddSilentConnectionFactory } from '../types';\n\nexport const createAddSilentConnection: TAddSilentConnectionFactory = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n", "import { TAddUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createAddUnrenderedAudioWorkletNode: TAddUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n", "import { IAnalyserNode, IAnalyserOptions } from '../interfaces';\nimport { TAnalyserNodeConstructorFactory, TAudioNodeRenderer, TContext, TNativeAnalyserNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n} as const;\n\nexport const createAnalyserNodeConstructor: TAnalyserNodeConstructorFactory = (\n    audionNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class AnalyserNode<T extends TContext> extends audionNodeConstructor<T> implements IAnalyserNode<T> {\n        private _nativeAnalyserNode: TNativeAnalyserNode;\n\n        constructor(context: T, options?: Partial<IAnalyserOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n\n        get fftSize(): number {\n            return this._nativeAnalyserNode.fftSize;\n        }\n\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n\n        get frequencyBinCount(): number {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n\n        get maxDecibels(): number {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n\n            this._nativeAnalyserNode.maxDecibels = value;\n\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get minDecibels(): number {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n\n            this._nativeAnalyserNode.minDecibels = value;\n\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get smoothingTimeConstant(): number {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n\n        public getByteFrequencyData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n\n        public getByteTimeDomainData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n\n        public getFloatFrequencyData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n\n        public getFloatTimeDomainData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n", "import { TNativeAudioNode, TNativeContext } from '../types';\n\nexport const isOwnedByContext = (nativeAudioNode: TNativeAudioNode, nativeContext: TNativeContext): boolean => {\n    return nativeAudioNode.context === nativeContext;\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAnalyserNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAnalyserNodeRendererFactoryFactory, TNativeAnalyserNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAnalyserNodeRendererFactory: TAnalyserNodeRendererFactoryFactory = (\n    createNativeAnalyserNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAnalyserNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAnalyserNode>();\n\n        const createAnalyserNode = async (proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode<T, TNativeAnalyserNode>(proxy);\n\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n\n            return nativeAnalyserNode;\n        };\n\n        return {\n            render(proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAnalyserNode> {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TNativeAudioBuffer } from '../types';\n\nexport const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer: TNativeAudioBuffer): boolean => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TIndexSizeErrorFactory } from '../types';\n\nexport const createIndexSizeError: TIndexSizeErrorFactory = () => new DOMException('', 'IndexSizeError');\n", "import { createIndexSizeError } from '../factories/index-size-error';\nimport { TNativeAudioBuffer } from '../types';\n\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer: TNativeAudioBuffer): void => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel: number) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            } catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n", "import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n", "export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsActiveAudioNodeFunction } from '../types';\n\nexport const isActiveAudioNode: TIsActiveAudioNodeFunction = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioBufferSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioBufferSourceNodeRendererFactoryFactory, TNativeAudioBufferSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAudioBufferSourceNodeRendererFactory: TAudioBufferSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode>();\n\n        let start: null | [number, number] | [number, number, number] = null;\n        let stop: null | number = null;\n\n        const createAudioBufferSourceNode = async (\n            proxy: IAudioBufferSourceNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode<T, TNativeAudioBufferSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            } else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            return nativeAudioBufferSourceNode;\n        };\n\n        return {\n            set start(value: [number, number] | [number, number, number]) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IAudioBufferSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode> {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IAudioBufferSourceNode, IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioBufferSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioBufferSourceNode<T> => {\n    return 'playbackRate' in audioNode;\n};\n", "import { IAudioNode, IBiquadFilterNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isBiquadFilterNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IBiquadFilterNode<T> => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n", "import { IAudioNode, IConstantSourceNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isConstantSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IConstantSourceNode<T> => {\n    return 'offset' in audioNode;\n};\n", "import { IAudioNode, IGainNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isGainNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IGainNode<T> => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n", "import { IAudioNode, IOscillatorNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isOscillatorNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IOscillatorNode<T> => {\n    return 'detune' in audioNode && 'frequency' in audioNode;\n};\n", "import { IAudioNode, IStereoPannerNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isStereoPannerNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IStereoPannerNode<T> => {\n    return 'pan' in audioNode;\n};\n", "import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TAudioNodeConnections, TContext, TGetAudioNodeConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioNodeConnections: TGetAudioNodeConnectionsFunction = <T extends TContext>(\n    audioNode: IAudioNode<T>\n): TAudioNodeConnections<T> => {\n    return <TAudioNodeConnections<T>>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n", "import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioParamConnections, TContext, TGetAudioParamConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioParamConnections: TGetAudioParamConnectionsFunction = <T extends TContext>(\n    audioParam: IAudioParam\n): TAudioParamConnections<T> => {\n    return <TAudioParamConnections<T>>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n", "import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\nexport const deactivateActiveAudioNodeInputConnections = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    trace: readonly IAudioNode<T>[]\n) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n\n    activeInputs.forEach((connections) =>\n        connections.forEach(([source]) => {\n            if (!trace.includes(audioNode)) {\n                deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n            }\n        })\n    );\n\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n              // Bug #149: Safari does not yet support the detune AudioParam.\n              audioNode.playbackRate\n          ]\n        : isAudioWorkletNode(audioNode)\n        ? Array.from(audioNode.parameters.values())\n        : isBiquadFilterNode(audioNode)\n        ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n        : isConstantSourceNode(audioNode)\n        ? [audioNode.offset]\n        : isGainNode(audioNode)\n        ? [audioNode.gain]\n        : isOscillatorNode(audioNode)\n        ? [audioNode.detune, audioNode.frequency]\n        : isStereoPannerNode(audioNode)\n        ? [audioNode.pan]\n        : [];\n\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\n\nexport const deactivateAudioGraph = <T extends TContext>(context: T): void => {\n    deactivateActiveAudioNodeInputConnections(<IAudioDestinationNode<T>>context.destination, []);\n};\n", "import { IAudioContextOptions } from '../interfaces';\n\nexport const isValidLatencyHint = (latencyHint: IAudioContextOptions['latencyHint']) => {\n    return (\n        latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'))\n    );\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport {\n    IAudioContext,\n    IAudioContextOptions,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode\n} from '../interfaces';\nimport { TAudioContextConstructorFactory, TAudioContextState, TNativeAudioContext, TNativeGainNode, TNativeOscillatorNode } from '../types';\n\nexport const createAudioContextConstructor: TAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class AudioContext extends baseAudioContextConstructor<IAudioContext> implements IAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public createMediaElementSource(mediaElement: HTMLMediaElement): IMediaElementAudioSourceNode<this> {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n\n        public createMediaStreamDestination(): IMediaStreamAudioDestinationNode<this> {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n\n        public createMediaStreamSource(mediaStream: MediaStream): IMediaStreamAudioSourceNode<this> {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n\n        public createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): IMediaStreamTrackAudioSourceNode<this> {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport {\n    TAudioDestinationNodeConstructorFactory,\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TNativeAudioDestinationNode\n} from '../types';\n\nexport const createAudioDestinationNodeConstructor: TAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n) => {\n    return class AudioDestinationNode<T extends TContext> extends audioNodeConstructor<T> implements IAudioDestinationNode<T> {\n        private _isNodeOfNativeOfflineAudioContext: boolean;\n\n        private _nativeAudioDestinationNode: TNativeAudioDestinationNode;\n\n        constructor(context: T, channelCount: number) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null)\n            );\n\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n\n        get maxChannelCount(): number {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n", "import { IAudioDestinationNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TAudioDestinationNodeRendererFactory,\n    TNativeAudioDestinationNode,\n    TNativeOfflineAudioContext,\n    TRenderInputsOfAudioNodeFunction\n} from '../types';\n\nexport const createAudioDestinationNodeRenderer: TAudioDestinationNodeRendererFactory = <\n    T extends IMinimalOfflineAudioContext | IOfflineAudioContext\n>(\n    renderInputsOfAudioNode: TRenderInputsOfAudioNodeFunction\n) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioDestinationNode>();\n\n    const createAudioDestinationNode = async (proxy: IAudioDestinationNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        return nativeAudioDestinationNode;\n    };\n\n    return {\n        render(\n            proxy: IAudioDestinationNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ): Promise<TNativeAudioDestinationNode> {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioListenerFactoryFactory } from '../types';\n\nexport const createAudioListenerFactory: TAudioListenerFactoryFactory = (\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation: [number, number, number, number, number, number] = [0, 0, -1, 0, 1, 0];\n            let lastPosition: [number, number, number] = [0, 0, 0];\n\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n\n                isScriptProcessorNodeCreated = true;\n\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation: [number, number, number, number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                        lastOrientation = orientation;\n                    }\n\n                    const positon: [number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n                        lastPosition = positon;\n                    }\n                };\n\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index: number) => (value: number) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index: number) => (value: number) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input: number, initialValue: number, setValue: (value: number) => void) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n\n                constantSourceNode.connect(channelMergerNode, 0, input);\n\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get(): number {\n                        return initialValue;\n                    }\n                });\n\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam(\n                    <any>{ context },\n                    isOffline,\n                    constantSourceNode.offset,\n                    MOST_POSITIVE_SINGLE_FLOAT,\n                    MOST_NEGATIVE_SINGLE_FLOAT\n                );\n\n                overwriteAccessors(\n                    audioParam,\n                    'value',\n                    (get) => () => get.call(audioParam),\n                    (set) => (value) => {\n                        try {\n                            set.call(audioParam, value);\n                        } catch (err) {\n                            if (err.code !== 9) {\n                                throw err;\n                            }\n                        }\n\n                        createScriptProcessorNode();\n\n                        if (isOffline) {\n                            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                            setValue(value);\n                        }\n                    }\n                );\n\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelAndHoldAtTime']>) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelScheduledValues']>) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['exponentialRampToValueAtTime']>) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['linearRampToValueAtTime']>) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setTargetAtTime']>) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueAtTime']>) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueCurveAtTime']>) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n\n                return audioParam;\n            };\n\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } =\n            nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n\n        return {\n            get forwardX(): IAudioParam {\n                return forwardX;\n            },\n            get forwardY(): IAudioParam {\n                return forwardY;\n            },\n            get forwardZ(): IAudioParam {\n                return forwardZ;\n            },\n            get positionX(): IAudioParam {\n                return positionX;\n            },\n            get positionY(): IAudioParam {\n                return positionY;\n            },\n            get positionZ(): IAudioParam {\n                return positionZ;\n            },\n            get upX(): IAudioParam {\n                return upX;\n            },\n            get upY(): IAudioParam {\n                return upY;\n            },\n            get upZ(): IAudioParam {\n                return upZ;\n            }\n        };\n    };\n};\n", "import { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioNode = <T extends TContext>(\n    audioNodeOrAudioParam: IAudioNode<T> | IAudioParam\n): audioNodeOrAudioParam is IAudioNode<T> => {\n    return 'context' in audioNodeOrAudioParam;\n};\n", "import { TAudioNodeOutputConnection, TContext, TOutputConnection } from '../types';\nimport { isAudioNode } from './audio-node';\n\nexport const isAudioNodeOutputConnection = <T extends TContext>(\n    outputConnection: TOutputConnection<T>\n): outputConnection is TAudioNodeOutputConnection<T> => {\n    return isAudioNode(outputConnection[0]);\n};\n", "import { TInsertElementInSetFunction } from '../types';\n\nexport const insertElementInSet: TInsertElementInSetFunction = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n\n    set.add(element);\n\n    return true;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    [output, eventListener]: TPassiveAudioParamInputConnection,\n    ignoreDuplicates: boolean\n) => {\n    insertElementInSet(\n        activeInputs,\n        [source, output, eventListener],\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n        ignoreDuplicates\n    );\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addPassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    [source, output, eventListener]: TActiveInputConnection<T>,\n    ignoreDuplicates: boolean\n) => {\n    const passiveInputConnections = passiveInputs.get(source);\n\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    } else {\n        insertElementInSet(\n            passiveInputConnections,\n            [output, eventListener],\n            (passiveInputConnection) => passiveInputConnection[0] === output,\n            ignoreDuplicates\n        );\n    }\n};\n", "import { INativeAudioNodeFaker } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\n\nexport const isNativeAudioNodeFaker = (\n    nativeAudioNodeOrNativeAudioNodeFaker: TNativeAudioNode | INativeAudioNodeFaker\n): nativeAudioNodeOrNativeAudioNodeFaker is INativeAudioNodeFaker => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { INativeAudioNodeFaker } from '../interfaces';\nimport { TConnectNativeAudioNodeToNativeAudioNodeFunction, TNativeAudioNode } from '../types';\n\nexport const connectNativeAudioNodeToNativeAudioNode: TConnectNativeAudioNodeToNativeAudioNodeFunction = (\n    nativeSourceAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    nativeDestinationAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    output: number,\n    input: number\n): [TNativeAudioNode, number, number] => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n\n    return [nativeDestinationAudioNode, output, input];\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\n\nexport const deleteActiveInputConnection = <T extends TContext>(\n    activeInputConnections: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n): null | TActiveInputConnection<T> => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n\n            return activeInputConnection;\n        }\n    }\n\n    return null;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deleteActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    return pickElementFromSet(\n        activeInputs,\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n    );\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TInternalStateEventListener } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const deleteEventListenerOfAudioNode = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    eventListener: TInternalStateEventListener\n) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { TDisconnectNativeAudioNodeFromNativeAudioNodeFunction } from '../types';\n\nexport const disconnectNativeAudioNodeFromNativeAudioNode: TDisconnectNativeAudioNodeFromNativeAudioNodeFunction = (\n    nativeSourceAudioNode,\n    nativeDestinationAudioNode,\n    output,\n    input\n) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n", "import { AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode, INativeAudioNodeFaker } from '../interfaces';\nimport { TContext, TGetNativeAudioNodeFunction, TNativeAudioNode } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioNode: TGetNativeAudioNodeFunction = <T extends TContext, U extends TNativeAudioNode | INativeAudioNodeFaker>(\n    audioNode: IAudioNode<T>\n): U => {\n    return <U>getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n", "import { AUDIO_PARAM_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TNativeAudioParam } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioParam = (audioParam: IAudioParam): TNativeAudioParam => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n", "import { CYCLE_COUNTERS } from '../globals';\nimport { TIsPartOfACycleFunction } from '../types';\n\nexport const isPartOfACycle: TIsPartOfACycleFunction = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsPassiveAudioNodeFunction } from '../types';\n\nexport const isPassiveAudioNode: TIsPassiveAudioNodeFunction = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n", "import { TNativeAudioContext, TNativeAudioWorkletNodeConstructor } from '../types';\n\nexport const testAudioNodeDisconnectMethodSupport = (\n    nativeAudioContext: TNativeAudioContext,\n    nativeAudioWorkletNodeConstructor: null | TNativeAudioWorkletNodeConstructor\n): Promise<boolean> => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        } else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n\n            channelData[0] = 1;\n            channelData[1] = 1;\n\n            const source = nativeAudioContext.createBufferSource();\n\n            source.buffer = ones;\n            source.loop = true;\n\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n\n                if (Array.prototype.some.call(chnnlDt, (sample: number) => sample === 1)) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n\n                source.stop();\n\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n\n            source.start();\n        }\n    });\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const visitEachAudioNodeOnce = <T extends TContext>(\n    cycles: IAudioNode<T>[][],\n    visitor: (audioNode: IAudioNode<T>, count: number) => void\n): void => {\n    const counts = new Map<IAudioNode<T>, number>();\n\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n", "import { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const isNativeAudioNode = (\n    nativeAudioNodeOrAudioParam: TNativeAudioNode | TNativeAudioParam\n): nativeAudioNodeOrAudioParam is TNativeAudioNode => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n", "import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n", "import { AutomationEventList } from 'automation-events';\nimport { IAudioNode, IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioParamFactoryFactory, TContext, TNativeAudioParam } from '../types';\n\nexport const createAudioParamFactory: TAudioParamFactoryFactory = (\n    addAudioParamConnections,\n    audioParamAudioNodeStore,\n    audioParamStore,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        isAudioParamOfOfflineAudioContext: boolean,\n        nativeAudioParam: TNativeAudioParam,\n        maxValue: null | number = null,\n        minValue: null | number = null\n    ): IAudioParam => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue(): number {\n                return defaultValue;\n            },\n            get maxValue(): number {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue(): number {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value(): number {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime: number): IAudioParam {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                } else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n\n                    const currentLastEvent = Array.from(automationEventList).pop();\n\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        } else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(\n                                currentLastEvent.values,\n                                currentLastEvent.startTime,\n                                currentLastEvent.duration\n                            );\n                        }\n                    }\n                }\n\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            linearRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            setTargetAtTime(target: number, startTime: number, timeConstant: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n\n                return audioParam;\n            },\n            setValueAtTime(value: number, startTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n\n                return audioParam;\n            },\n            setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): IAudioParam {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n\n                    const timeOfLastSample = lastSample / sampleRate;\n\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                } else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n\n                return audioParam;\n            }\n        };\n\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n\n        addAudioParamConnections(\n            audioParam,\n            <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null>audioParamRenderer\n        );\n\n        return audioParam;\n    };\n};\n", "import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n", "import { IReadOnlyMap } from './interfaces';\n\nexport class ReadOnlyMap<T, U> implements IReadOnlyMap<T, U> {\n    private _map: Map<T, U>;\n\n    constructor(parameters: [T, U][]) {\n        this._map = new Map(parameters);\n    }\n\n    get size(): number {\n        return this._map.size;\n    }\n\n    public entries(): IterableIterator<[T, U]> {\n        return this._map.entries();\n    }\n\n    public forEach(callback: (audioParam: U, name: T, map: ReadOnlyMap<T, U>) => void, thisArg: any = null): void {\n        return this._map.forEach((value: U, key: T) => callback.call(thisArg, value, key, this));\n    }\n\n    public get(name: T): undefined | U {\n        return this._map.get(name);\n    }\n\n    public has(name: T): boolean {\n        return this._map.has(name);\n    }\n\n    public keys(): IterableIterator<T> {\n        return this._map.keys();\n    }\n\n    public values(): IterableIterator<U> {\n        return this._map.values();\n    }\n}\n", "import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n", "import { TNativeAudioBuffer } from '../types';\n\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: string]: Float32Array },\n    key: string,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent: any,\n    key: number | string,\n    channelNumber: number,\n    bufferOffset: number\n): void {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n\n        // Bug #5: Safari does not support copyFromChannel().\n    } else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n\n            parent[key].set(slicedInput);\n        }\n    }\n}\n", "import { TNativeAudioBuffer } from '../types';\n\nexport const copyToChannel = (\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n\n        // Bug #5: Safari does not support copyToChannel().\n    } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n", "export const createNestedArrays = (x: number, y: number | number[]): Float32Array[][] => {\n    const arrays: Float32Array[][] = [];\n\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n\n        const length = typeof y === 'number' ? y : y[i];\n\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n\n        arrays.push(array);\n    }\n\n    return arrays;\n};\n", "import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioNode, IAudioWorkletProcessor } from '../interfaces';\nimport { TContext, TNativeAudioWorkletNode, TNativeOfflineAudioContext } from '../types';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioWorkletProcessor = <T extends TContext>(\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    proxy: IAudioNode<T>\n): Promise<IAudioWorkletProcessor> => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n", "import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioNode,\n    IAudioWorklet,\n    IBaseAudioContext,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IPeriodicWaveConstraints,\n    IStereoPannerNode,\n    IWaveShaperNode,\n    IWorkletOptions\n} from '../interfaces';\nimport { TBaseAudioContextConstructorFactory, TContext, TDecodeErrorCallback, TDecodeSuccessCallback, TNativeContext } from '../types';\n\nexport const createBaseAudioContextConstructor: TBaseAudioContextConstructorFactory = (\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n) => {\n    return class BaseAudioContext<T extends TContext> extends minimalBaseAudioContextConstructor<T> implements IBaseAudioContext<T> {\n        private _audioWorklet: undefined | IAudioWorklet;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext, numberOfChannels);\n\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                          addModule: (moduleURL: string, options?: IWorkletOptions) => {\n                              return addAudioWorkletModule(<T>(<unknown>this), moduleURL, options);\n                          }\n                      };\n        }\n\n        get audioWorklet(): undefined | IAudioWorklet {\n            return this._audioWorklet;\n        }\n\n        public createAnalyser(): IAnalyserNode<T> {\n            return new analyserNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBiquadFilter(): IBiquadFilterNode<T> {\n            return new biquadFilterNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBuffer(numberOfChannels: number, length: number, sampleRate: number): IAudioBuffer {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n\n        public createBufferSource(): IAudioBufferSourceNode<T> {\n            return new audioBufferSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createChannelMerger(numberOfInputs = 6): IAudioNode<T> {\n            return new channelMergerNodeConstructor(<T>(<unknown>this), { numberOfInputs });\n        }\n\n        public createChannelSplitter(numberOfOutputs = 6): IAudioNode<T> {\n            return new channelSplitterNodeConstructor(<T>(<unknown>this), { numberOfOutputs });\n        }\n\n        public createConstantSource(): IConstantSourceNode<T> {\n            return new constantSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createConvolver(): IConvolverNode<T> {\n            return new convolverNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createDelay(maxDelayTime = 1): IDelayNode<T> {\n            return new delayNodeConstructor(<T>(<unknown>this), { maxDelayTime });\n        }\n\n        public createDynamicsCompressor(): IDynamicsCompressorNode<T> {\n            return new dynamicsCompressorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createGain(): IGainNode<T> {\n            return new gainNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIIRFilterNode<T> {\n            return new iIRFilterNodeConstructor(<T>(<unknown>this), { feedback, feedforward });\n        }\n\n        public createOscillator(): IOscillatorNode<T> {\n            return new oscillatorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPanner(): IPannerNode<T> {\n            return new pannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPeriodicWave(\n            real: Iterable<number>,\n            imag: Iterable<number>,\n            constraints: Partial<IPeriodicWaveConstraints> = { disableNormalization: false }\n        ): IPeriodicWave {\n            return new periodicWaveConstructor(<T>(<unknown>this), { ...constraints, imag, real });\n        }\n\n        public createStereoPanner(): IStereoPannerNode<T> {\n            return new stereoPannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createWaveShaper(): IWaveShaperNode<T> {\n            return new waveShaperNodeConstructor(<T>(<unknown>this));\n        }\n\n        public decodeAudioData(\n            audioData: ArrayBuffer,\n            successCallback?: TDecodeSuccessCallback,\n            errorCallback?: TDecodeErrorCallback\n        ): Promise<IAudioBuffer> {\n            return decodeAudioData(this._nativeContext, audioData).then(\n                (audioBuffer) => {\n                    if (typeof successCallback === 'function') {\n                        successCallback(audioBuffer);\n                    }\n\n                    return audioBuffer;\n                },\n                (err) => {\n                    if (typeof errorCallback === 'function') {\n                        errorCallback(err);\n                    }\n\n                    throw err;\n                }\n            );\n        }\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IBiquadFilterNode, IBiquadFilterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TBiquadFilterNodeConstructorFactory, TBiquadFilterType, TContext, TNativeBiquadFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n} as const;\n\nexport const createBiquadFilterNodeConstructor: TBiquadFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class BiquadFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IBiquadFilterNode<T> {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _gain: IAudioParam;\n\n        private _nativeBiquadFilterNode: TNativeBiquadFilterNode;\n\n        private _Q: IAudioParam;\n\n        constructor(context: T, options?: Partial<IBiquadFilterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createBiquadFilterNodeRenderer() : null);\n\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.detune,\n                1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT),\n                -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT)\n            );\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.gain,\n                40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT),\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n\n        get Q(): IAudioParam {\n            return this._Q;\n        }\n\n        get type(): TBiquadFilterType {\n            return this._nativeBiquadFilterNode.type;\n        }\n\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IBiquadFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TBiquadFilterNodeRendererFactoryFactory, TNativeBiquadFilterNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createBiquadFilterNodeRendererFactory: TBiquadFilterNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeBiquadFilterNodes = new WeakMap<TNativeOfflineAudioContext, TNativeBiquadFilterNode>();\n\n        const createBiquadFilterNode = async (proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode<T, TNativeBiquadFilterNode>(proxy);\n\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            return nativeBiquadFilterNode;\n        };\n\n        return {\n            render(proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeBiquadFilterNode> {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TCacheTestResultFactory } from '../types';\n\nexport const createCacheTestResult: TCacheTestResultFactory = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n\n        const ongoingTest = ongoingTests.get(tester);\n\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n\n        try {\n            const synchronousTestResult = test();\n\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                        ongoingTests.delete(tester);\n                        testResults.set(tester, finalTestResult);\n\n                        return finalTestResult;\n                    });\n            }\n\n            testResults.set(tester, synchronousTestResult);\n\n            return synchronousTestResult;\n        } catch {\n            testResults.set(tester, false);\n\n            return false;\n        }\n    };\n};\n", "import { IChannelMergerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelMergerNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n} as const;\n\nexport const createChannelMergerNodeConstructor: TChannelMergerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class ChannelMergerNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelMergerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelMergerNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelMergerNodeRendererFactory: TChannelMergerNodeRendererFactoryFactory = (\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IChannelSplitterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelSplitterNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n} as const;\n\nexport const createChannelSplitterNodeConstructor: TChannelSplitterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n) => {\n    return class ChannelSplitterNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelSplitterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelSplitterNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelSplitterNodeRendererFactory: TChannelSplitterNodeRendererFactoryFactory = (\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TConnectAudioParamFactory } from '../types';\n\nexport const createConnectAudioParam: TConnectAudioParamFactory = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TConnectMultipleOutputsFactory } from '../types';\n\nexport const createConnectMultipleOutputs: TConnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n", "import { TConnectedNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createConnectedNativeAudioBufferSourceNodeFactory: TConnectedNativeAudioBufferSourceNodeFactoryFactory = (\n    createNativeAudioBufferSourceNode\n) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioParam, IAudioScheduledSourceNodeEventMap, IConstantSourceNode, IConstantSourceOptions } from '../interfaces';\nimport {\n    TConstantSourceNodeConstructorFactory,\n    TConstantSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeConstantSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n} as const;\n\nexport const createConstantSourceNodeConstructor: TConstantSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRendererFactory,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class ConstantSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IConstantSourceNode<T>\n    {\n        private _constantSourceNodeRenderer: TConstantSourceNodeRenderer<T>;\n\n        private _nativeConstantSourceNode: TNativeConstantSourceNode;\n\n        private _offset: IAudioParam;\n\n        private _onended: null | TEventHandler<this>;\n\n        constructor(context: T, options?: Partial<IConstantSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = <TConstantSourceNodeRenderer<T>>(\n                (isOffline ? createConstantSourceNodeRendererFactory() : null)\n            );\n\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(\n                this,\n                isOffline,\n                nativeConstantSourceNode.offset,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._onended = null;\n        }\n\n        get offset(): IAudioParam {\n            return this._offset;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeConstantSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        public start(when = 0): void {\n            this._nativeConstantSourceNode.start(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeConstantSourceNode.stop(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConstantSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConstantSourceNodeRendererFactoryFactory, TNativeConstantSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConstantSourceNodeRendererFactory: TConstantSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConstantSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConstantSourceNode>();\n\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createConstantSourceNode = async (proxy: IConstantSourceNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode<T, TNativeConstantSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            return nativeConstantSourceNode;\n        };\n\n        return {\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IConstantSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeConstantSourceNode> {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TConvertNumberToUnsignedLongFactory } from '../types';\n\nexport const createConvertNumberToUnsignedLong: TConvertNumberToUnsignedLongFactory = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n\n        return unit32Array[0];\n    };\n};\n", "import { IConvolverNode, IConvolverOptions } from '../interfaces';\nimport { TAnyAudioBuffer, TAudioNodeRenderer, TContext, TConvolverNodeConstructorFactory, TNativeConvolverNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n} as const;\n\nexport const createConvolverNodeConstructor: TConvolverNodeConstructorFactory = (\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class ConvolverNode<T extends TContext> extends audioNodeConstructor<T> implements IConvolverNode<T> {\n        private _isBufferNullified: boolean;\n\n        private _nativeConvolverNode: TNativeConvolverNode;\n\n        constructor(context: T, options?: Partial<IConvolverOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createConvolverNodeRenderer() : null);\n\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeConvolverNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n\n                setAudioNodeTailTime(this, 0);\n            } else {\n                this._isBufferNullified = false;\n\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n\n        get normalize(): boolean {\n            return this._nativeConvolverNode.normalize;\n        }\n\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConvolverNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConvolverNodeRendererFactoryFactory, TNativeConvolverNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConvolverNodeRendererFactory: TConvolverNodeRendererFactoryFactory = (\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConvolverNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConvolverNode>();\n\n        const createConvolverNode = async (proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode<T, TNativeConvolverNode>(proxy);\n\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            }\n\n            return nativeConvolverNode;\n        };\n\n        return {\n            render(proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeConvolverNode> {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TCreateNativeOfflineAudioContextFactory } from '../types';\n\nexport const createCreateNativeOfflineAudioContext: TCreateNativeOfflineAudioContextFactory = (\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n\n            throw err;\n        }\n    };\n};\n", "import { TDataCloneErrorFactory } from '../types';\n\nexport const createDataCloneError: TDataCloneErrorFactory = () => new DOMException('', 'DataCloneError');\n", "export const detachArrayBuffer = (arrayBuffer: ArrayBuffer): Promise<void> => {\n    const { port1, port2 } = new MessageChannel();\n\n    return new Promise((resolve) => {\n        const closeAndResolve = () => {\n            port2.onmessage = null;\n\n            port1.close();\n            port2.close();\n\n            resolve();\n        };\n\n        port2.onmessage = () => closeAndResolve();\n\n        try {\n            port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } catch {\n            // Ignore errors.\n        } finally {\n            closeAndResolve();\n        }\n    });\n};\n", "import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TDecodeAudioDataFactory } from '../types';\n\nexport const createDecodeAudioData: TDecodeAudioDataFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    detachedArrayBuffers,\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n\n            return Promise.reject(err);\n        }\n\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                detachArrayBuffer(audioData).catch(() => {\n                    // Ignore errors.\n                });\n\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n        }\n\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = async () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    await detachArrayBuffer(audioData);\n                } catch {\n                    // Ignore errors.\n                }\n            };\n\n            const fail = (err: DOMException | Error) => {\n                reject(err);\n                complete();\n            };\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(\n                    audioData,\n                    (audioBuffer) => {\n                        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                        if (typeof audioBuffer.copyFromChannel !== 'function') {\n                            wrapAudioBufferCopyChannelMethods(audioBuffer);\n                            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                        }\n\n                        audioBufferStore.add(audioBuffer);\n\n                        complete().then(() => resolve(audioBuffer));\n                    },\n                    (err: DOMException | Error) => {\n                        // Bug #4: Safari returns null instead of an error.\n                        if (err === null) {\n                            fail(createEncodingError());\n                        } else {\n                            fail(err);\n                        }\n                    }\n                );\n            } catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n", "import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TDecrementCycleCounterFactory } from '../types';\n\nexport const createDecrementCycleCounter: TDecrementCycleCounterFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    cycleCounters,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    getNativeContext,\n    isActiveAudioNode,\n    isNativeOfflineAudioContext\n) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    } else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        } else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n", "import { IAudioParam, IDelayNode, IDelayOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TDelayNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n} as const;\n\nexport const createDelayNodeConstructor: TDelayNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DelayNode<T extends TContext> extends audioNodeConstructor<T> implements IDelayNode<T> {\n        private _delayTime: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDelayOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n\n        get delayTime(): IAudioParam {\n            return this._delayTime;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDelayNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDelayNodeRendererFactoryFactory, TNativeDelayNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDelayNodeRendererFactory: TDelayNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(maxDelayTime: number) => {\n        const renderedNativeDelayNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDelayNode>();\n\n        const createDelayNode = async (proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode<T, TNativeDelayNode>(proxy);\n\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n\n            return nativeDelayNode;\n        };\n\n        return {\n            render(proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeDelayNode> {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TDeleteActiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createDeleteActiveInputConnectionToAudioNode: TDeleteActiveInputConnectionToAudioNodeFactory = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(\n            activeInputs[input],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n        );\n    };\n};\n", "import { TDeleteUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createDeleteUnrenderedAudioWorkletNode: TDeleteUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n", "import { IAudioNode, IDelayNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isDelayNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IDelayNode<T> => {\n    return 'delayTime' in audioNode;\n};\n", "import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nimport { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext, TDetectCyclesFactory } from '../types';\n\nexport const createDetectCycles: TDetectCyclesFactory = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles<T extends TContext>(chain: IAudioNode<T>[], nextLink: IAudioNode<T> | IAudioParam): IAudioNode<T>[][] {\n        const audioNode = isAudioNode(nextLink) ? nextLink : <IAudioNode<T>>getValueForKey(audioParamAudioNodeStore, nextLink);\n\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n\n        const { outputs } = getAudioNodeConnections(audioNode);\n\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TDisconnectMultipleOutputsFactory, TIndexSizeErrorFactory, TNativeAudioNode } from '../types';\n\nconst getOutputAudioNodeAtIndex = (\n    createIndexSizeError: TIndexSizeErrorFactory,\n    outputAudioNodes: TNativeAudioNode[],\n    output: number\n): TNativeAudioNode => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n\n    return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs: TDisconnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n", "import { IAudioParam, IDynamicsCompressorNode, IDynamicsCompressorOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TDynamicsCompressorNodeConstructorFactory,\n    TNativeAudioParam,\n    TNativeDynamicsCompressorNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n} as const;\n\nexport const createDynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DynamicsCompressorNode<T extends TContext> extends audioNodeConstructor<T> implements IDynamicsCompressorNode<T> {\n        private _attack: IAudioParam;\n\n        private _knee: IAudioParam;\n\n        private _nativeDynamicsCompressorNode: TNativeDynamicsCompressorNode;\n\n        private _ratio: IAudioParam;\n\n        private _release: IAudioParam;\n\n        private _threshold: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDynamicsCompressorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDynamicsCompressorNodeRenderer() : null);\n\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n\n            setAudioNodeTailTime(this, 0.006);\n        }\n\n        get attack(): IAudioParam {\n            return this._attack;\n        }\n\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount(): number {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n\n            this._nativeDynamicsCompressorNode.channelCount = value;\n\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        /*\n         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        get knee(): IAudioParam {\n            return this._knee;\n        }\n\n        get ratio(): IAudioParam {\n            return this._ratio;\n        }\n\n        get reduction(): number {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value === 'number') {\n                return (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value;\n            }\n\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n\n        get release(): IAudioParam {\n            return this._release;\n        }\n\n        get threshold(): IAudioParam {\n            return this._threshold;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDynamicsCompressorNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDynamicsCompressorNodeRendererFactoryFactory, TNativeDynamicsCompressorNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDynamicsCompressorNodeRendererFactory: TDynamicsCompressorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDynamicsCompressorNode>();\n\n        const createDynamicsCompressorNode = async (\n            proxy: IDynamicsCompressorNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode<T, TNativeDynamicsCompressorNode>(proxy);\n\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            return nativeDynamicsCompressorNode;\n        };\n\n        return {\n            render(\n                proxy: IDynamicsCompressorNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeDynamicsCompressorNode> {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TEncodingErrorFactory } from '../types';\n\nexport const createEncodingError: TEncodingErrorFactory = () => new DOMException('', 'EncodingError');\n", "import { TEvaluateSourceFactory } from '../types';\n\nexport const createEvaluateSource: TEvaluateSourceFactory = (window) => {\n    return (source) =>\n        new Promise((resolve, reject) => {\n            if (window === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n\n                return;\n            }\n\n            const head = window.document.head;\n\n            if (head === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            } else {\n                const script = window.document.createElement('script');\n                // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n                const blob = new Blob([source], { type: 'application/javascript' });\n                const url = URL.createObjectURL(blob);\n\n                const originalOnErrorHandler = window.onerror;\n\n                const removeErrorEventListenerAndRevokeUrl = () => {\n                    window.onerror = originalOnErrorHandler;\n\n                    URL.revokeObjectURL(url);\n                };\n\n                window.onerror = (message, src, lineno, colno, error) => {\n                    // @todo Edge thinks the source is the one of the html document.\n                    if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                        removeErrorEventListenerAndRevokeUrl();\n                        reject(error);\n\n                        return false;\n                    }\n\n                    if (originalOnErrorHandler !== null) {\n                        return originalOnErrorHandler(message, src, lineno, colno, error);\n                    }\n                };\n\n                script.onerror = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    reject(new SyntaxError());\n                };\n                script.onload = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    resolve();\n                };\n                script.src = url;\n                script.type = 'module';\n\n                head.appendChild(script);\n            }\n        });\n};\n", "import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        constructor(private _nativeEventTarget: TNativeEventTarget) {\n            this._listeners = new WeakMap();\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n", "import { TExposeCurrentFrameAndCurrentTimeFactory } from '../types';\n\nexport const createExposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFactory = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get(): number {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get(): number {\n                    return currentTime;\n                }\n            }\n        });\n\n        try {\n            return fn();\n        } finally {\n            if (window !== null) {\n                delete (<any>window).currentFrame;\n                delete (<any>window).currentTime;\n            }\n        }\n    };\n};\n", "import { TFetchSourceFactory } from '../types';\n\nexport const createFetchSource: TFetchSourceFactory = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        } catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n\n        throw createAbortError();\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IGainNode, IGainOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TGainNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n} as const;\n\nexport const createGainNodeConstructor: TGainNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class GainNode<T extends TContext> extends audioNodeConstructor<T> implements IGainNode<T> {\n        private _gain: IAudioParam;\n\n        constructor(context: T, options?: Partial<IGainOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createGainNodeRenderer() : null);\n\n            super(context, false, nativeGainNode, gainNodeRenderer);\n\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IGainNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGainNodeRendererFactoryFactory, TNativeGainNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createGainNodeRendererFactory: TGainNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeGainNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode>();\n\n        const createGainNode = async (proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode<T, TNativeGainNode>(proxy);\n\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n\n            return nativeGainNode;\n        };\n\n        return {\n            render(proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeGainNode> {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TActiveInputConnection, TContext, TGetActiveAudioWorkletNodeInputsFactory, TNativeAudioWorkletNode } from '../types';\n\nexport const createGetActiveAudioWorkletNodeInputs: TGetActiveAudioWorkletNodeInputsFactory = (\n    activeAudioWorkletNodeInputsStore,\n    getValueForKey\n) => {\n    return <T extends TContext>(nativeAudioWorkletNode: TNativeAudioWorkletNode) =>\n        <Set<TActiveInputConnection<T>>[]>getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n", "import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGetAudioNodeRendererFactory } from '../types';\n\nexport const createGetAudioNodeRenderer: TGetAudioNodeRendererFactory = (getAudioNodeConnections) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioNode: IAudioNode<T>\n    ): IAudioNodeRenderer<T, IAudioNode<T>> => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n\n        return <IAudioNodeRenderer<T, IAudioNode<T>>>audioNodeConnections.renderer;\n    };\n};\n", "import { TGetAudioNodeTailTimeFactory } from '../types';\n\nexport const createGetAudioNodeTailTime: TGetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode) => audioNodeTailTimeStore.get(audioNode) ?? 0;\n};\n", "import { IMinimalOfflineAudioContext } from '../interfaces';\nimport { TGetAudioParamRendererFactory } from '../types';\n\nexport const createGetAudioParamRenderer: TGetAudioParamRendererFactory = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections<IMinimalOfflineAudioContext>(audioParam);\n\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n\n        return audioParamConnections.renderer;\n    };\n};\n", "import { TGetBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetBackupOfflineAudioContext: TGetBackupOfflineAudioContextFactory = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n", "import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => new DOMException('', 'InvalidStateError');\n", "import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TContext, TGetNativeContextFactory, TNativeAudioContext, TNativeOfflineAudioContext } from '../types';\nimport { createInvalidStateError } from './invalid-state-error';\n\nexport const createGetNativeContext: TGetNativeContextFactory = (contextStore) => {\n    return <T extends TContext>(\n        context: T\n    ): T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext => {\n        const nativeContext = contextStore.get(context);\n\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n\n        return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext>(\n            nativeContext\n        );\n    };\n};\n", "import { TGetOrCreateBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetOrCreateBackupOfflineAudioContext: TGetOrCreateBackupOfflineAudioContextFactory = (\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n\n        return backupOfflineAudioContext;\n    };\n};\n", "import { TGetUnrenderedAudioWorkletNodesFactory } from '../types';\n\nexport const createGetUnrenderedAudioWorkletNodes: TGetUnrenderedAudioWorkletNodesFactory = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n\n        return unrenderedAudioWorkletNodes;\n    };\n};\n", "import { TInvalidAccessErrorFactory } from '../types';\n\nexport const createInvalidAccessError: TInvalidAccessErrorFactory = () => new DOMException('', 'InvalidAccessError');\n", "import { createInvalidAccessError } from '../factories/invalid-access-error';\nimport { TNativeIIRFilterNode } from '../types';\n\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode: TNativeIIRFilterNode): void => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n", "import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nimport { IIIRFilterNode, IIIRFilterOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TIIRFilterNodeConstructorFactory, TNativeIIRFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createIIRFilterNodeConstructor: TIIRFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class IIRFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IIIRFilterNode<T> {\n        private _nativeIIRFilterNode: TNativeIIRFilterNode;\n\n        constructor(\n            context: T,\n            options: { feedback: IIIRFilterOptions['feedback']; feedforward: IIIRFilterOptions['feedforward'] } & Partial<IIIRFilterOptions>\n        ) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(\n                nativeContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                mergedOptions\n            );\n            const iirFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null)\n            );\n\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n", "// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (\n    feedback: Float64Array,\n    feedbackLength: number,\n    feedforward: Float64Array,\n    feedforwardLength: number,\n    minLength: number,\n    xBuffer: Float32Array,\n    yBuffer: Float32Array,\n    bufferIndex: number,\n    bufferLength: number,\n    input: Float32Array,\n    output: Float32Array\n) => {\n    const inputLength = input.length;\n\n    let i = bufferIndex;\n\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n        output[j] = y;\n    }\n\n    return i;\n};\n", "import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IIIRFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TIIRFilterNodeRendererFactoryFactory,\n    TNativeAudioBuffer,\n    TNativeAudioBufferSourceNode,\n    TNativeIIRFilterNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst filterFullBuffer = (\n    renderedBuffer: TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    feedback: Iterable<number>,\n    feedforward: Iterable<number>\n) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(\n        renderedBuffer.numberOfChannels,\n        renderedBuffer.length,\n        renderedBuffer.sampleRate\n    );\n\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n\n        filterBuffer(\n            convertedFeedback,\n            feedbackLength,\n            convertedFeedforward,\n            feedforwardLength,\n            minLength,\n            xBuffer,\n            yBuffer,\n            0,\n            bufferLength,\n            input,\n            output\n        );\n    }\n\n    return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory: TIIRFilterNodeRendererFactoryFactory = (\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(feedback: Iterable<number>, feedforward: Iterable<number>) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode | TNativeIIRFilterNode>();\n\n        let filteredBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IIIRFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode: null | TNativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode<T, TNativeIIRFilterNode>(proxy);\n\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(<number[]>feedforward, <number[]>feedback);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode\n            );\n\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                        proxy.context.destination.channelCount,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n\n                const filteredBuffer = await filteredBufferPromise;\n\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n\n                return nativeAudioBufferSourceNode;\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n\n            return nativeIIRFilterNode;\n        };\n\n        return {\n            render(\n                proxy: IIIRFilterNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode | TNativeIIRFilterNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TIncrementCycleCounterFactoryFactory } from '../types';\n\nexport const createIncrementCycleCounterFactory: TIncrementCycleCounterFactoryFactory = (\n    cycleCounters,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    isActiveAudioNode\n) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                            disconnectNativeAudioNodeFromNativeAudioNode(\n                                nativeSourceAudioNode,\n                                nativeDestinationAudioNode,\n                                output[1],\n                                output[2]\n                            );\n                        } else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n\n                cycleCounters.set(audioNode, count);\n            } else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n", "import { IAudioContext, IMinimalAudioContext } from '../interfaces';\nimport { TIsAnyAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsAnyAudioContext: TIsAnyAudioContextFactory = (contextStore, isNativeAudioContext) => {\n    return (anything): anything is IAudioContext | IMinimalAudioContext | TNativeAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TIsAnyAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsAnyAudioNode: TIsAnyAudioNodeFactory = (audioNodeStore, isNativeAudioNode) => {\n    return (anything): anything is IAudioNode<any> | TNativeAudioNode => audioNodeStore.has(<any>anything) || isNativeAudioNode(anything);\n};\n", "import { IAudioParam } from '../interfaces';\nimport { TIsAnyAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsAnyAudioParam: TIsAnyAudioParamFactory = (audioParamStore, isNativeAudioParam) => {\n    return (anything): anything is IAudioParam | TNativeAudioParam => audioParamStore.has(<any>anything) || isNativeAudioParam(anything);\n};\n", "import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TIsAnyOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsAnyOfflineAudioContext: TIsAnyOfflineAudioContextFactory = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything): anything is IMinimalOfflineAudioContext | IOfflineAudioContext | TNativeOfflineAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n", "import { TIsNativeAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeAudioContext: TIsNativeAudioContextFactory = (nativeAudioContextConstructor) => {\n    return (anything): anything is TNativeAudioContext => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n", "import { TIsNativeAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsNativeAudioNode: TIsNativeAudioNodeFactory = (window) => {\n    return (anything): anything is TNativeAudioNode => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n", "import { TIsNativeAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsNativeAudioParam: TIsNativeAudioParamFactory = (window) => {\n    return (anything): anything is TNativeAudioParam => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n", "import { TIsNativeContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeContext: TIsNativeContextFactory = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything): anything is TNativeAudioContext => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n", "import { TIsNativeOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsNativeOfflineAudioContext: TIsNativeOfflineAudioContextFactory = (nativeOfflineAudioContextConstructor) => {\n    return (anything): anything is TNativeOfflineAudioContext => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n", "import { TIsSecureContextFactory } from '../types';\n\nexport const createIsSecureContext: TIsSecureContextFactory = (window) => window !== null && window.isSecureContext;\n", "import { IAudioContext, IMediaElementAudioSourceNode, IMediaElementAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaElementAudioSourceNodeConstructorFactory, TNativeMediaElementAudioSourceNode } from '../types';\n\nexport const createMediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaElementAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaElementAudioSourceNode<T> {\n        private _nativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNode;\n\n        constructor(context: T, options: IMediaElementAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n\n            super(context, true, nativeMediaElementAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n\n        get mediaElement(): HTMLMediaElement {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n", "import { IAudioContext, IAudioNodeOptions, IMediaStreamAudioDestinationNode, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioDestinationNodeConstructorFactory, TNativeMediaStreamAudioDestinationNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createMediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioDestinationNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioDestinationNode<T> {\n        private _nativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNode;\n\n        constructor(context: T, options?: Partial<IAudioNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n\n            super(context, false, nativeMediaStreamAudioDestinationNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n\n        get stream(): MediaStream {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n", "import { IAudioContext, IMediaStreamAudioSourceNode, IMediaStreamAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioSourceNodeConstructorFactory, TNativeMediaStreamAudioSourceNode } from '../types';\n\nexport const createMediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioSourceNode<T> {\n        private _nativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNode;\n\n        constructor(context: T, options: IMediaStreamAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            super(context, true, nativeMediaStreamAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n\n        get mediaStream(): MediaStream {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n", "import { IAudioContext, IMediaStreamTrackAudioSourceNode, IMediaStreamTrackAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamTrackAudioSourceNodeConstructorFactory } from '../types';\n\nexport const createMediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamTrackAudioSourceNode,\n    getNativeContext\n) => {\n    return class MediaStreamTrackAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamTrackAudioSourceNode<T> {\n        constructor(context: T, options: IMediaStreamTrackAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, <TAudioNodeRenderer<T>>null);\n        }\n    };\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport { IAudioContextOptions, IMinimalAudioContext } from '../interfaces';\nimport {\n    TAudioContextState,\n    TMinimalAudioContextConstructorFactory,\n    TNativeAudioContext,\n    TNativeGainNode,\n    TNativeOscillatorNode\n} from '../types';\n\nexport const createMinimalAudioContextConstructor: TMinimalAudioContextConstructorFactory = (\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor<IMinimalAudioContext> implements IMinimalAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n", "import { CONTEXT_STORE } from '../globals';\nimport { IAudioDestinationNode, IAudioListener, IMinimalBaseAudioContext, IMinimalBaseAudioContextEventMap } from '../interfaces';\nimport { TAudioContextState, TContext, TEventHandler, TMinimalBaseAudioContextConstructorFactory, TNativeContext } from '../types';\n\nexport const createMinimalBaseAudioContextConstructor: TMinimalBaseAudioContextConstructorFactory = (\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n) => {\n    return class MinimalBaseAudioContext<T extends TContext>\n        extends eventTargetConstructor<IMinimalBaseAudioContextEventMap>\n        implements IMinimalBaseAudioContext<T>\n    {\n        private _destination: IAudioDestinationNode<T>;\n\n        private _listener: IAudioListener;\n\n        private _onstatechange: null | TEventHandler<T>;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext);\n\n            CONTEXT_STORE.set(<T>(<unknown>this), _nativeContext);\n\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n\n            this._destination = new audioDestinationNodeConstructor(<T>(<unknown>this), numberOfChannels);\n            this._listener = createAudioListener(<T>(<unknown>this), _nativeContext);\n            this._onstatechange = null;\n        }\n\n        get currentTime(): number {\n            return this._nativeContext.currentTime;\n        }\n\n        get destination(): IAudioDestinationNode<T> {\n            return this._destination;\n        }\n\n        get listener(): IAudioListener {\n            return this._listener;\n        }\n\n        get onstatechange(): null | TEventHandler<T> {\n            return this._onstatechange;\n        }\n\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeContext.onstatechange = wrappedListener;\n\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n\n        get sampleRate(): number {\n            return this._nativeContext.sampleRate;\n        }\n\n        get state(): TAudioContextState {\n            return this._nativeContext.state;\n        }\n    };\n};\n", "import { TNativeContext } from '../types';\n\nexport const testPromiseSupport = (nativeContext: TNativeContext): boolean => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(<ArrayBuffer>uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n\n        if (promise === undefined) {\n            return false;\n        }\n\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n\n        return true;\n    } catch {\n        // Ignore errors.\n    }\n\n    return false;\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n", "import { TMonitorConnectionsFactory, TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const createMonitorConnections: TMonitorConnectionsFactory = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set<[TNativeAudioNode, number, number] | [TNativeAudioParam, number]>();\n\n        nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n                const wasDisconnected = connections.size === 0;\n\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    (<(destination: TNativeAudioNode, output?: number, input?: number) => TNativeAudioNode>connect).call(\n                        nativeAudioNode,\n                        destination,\n                        output,\n                        input\n                    );\n\n                    insertElementInSet(\n                        connections,\n                        [destination, output, input],\n                        (connection) => connection[0] === destination && connection[1] === output && connection[2] === input,\n                        true\n                    );\n\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n\n                    return destination;\n                }\n\n                connect.call(nativeAudioNode, destination, output);\n\n                insertElementInSet(\n                    connections,\n                    [destination, output],\n                    (connection) => connection[0] === destination && connection[1] === output,\n                    true\n                );\n\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n\n                return;\n            };\n        })(nativeAudioNode.connect);\n\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n                const wasConnected = connections.size > 0;\n\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n\n                    connections.clear();\n                } else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    (<(output: number) => void>disconnect).call(nativeAudioNode, destinationOrOutput);\n\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                } else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        (<(destination: TNativeAudioNode, output?: number, input?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output,\n                            input\n                        );\n                    } else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        (<(destination: TNativeAudioParam, output?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output\n                        );\n                    }\n\n                    for (const connection of connections) {\n                        if (\n                            connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)\n                        ) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n\n                const isDisconnected = connections.size === 0;\n\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n\n        return nativeAudioNode;\n    };\n};\n", "export const assignNativeAudioNodeOption = <T extends keyof any, U extends any>(\n    nativeAudioNode: Record<T, U>,\n    options: Record<T, U>,\n    option: T\n) => {\n    const value = options[option];\n\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n", "import { IAudioNodeOptions } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\nimport { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\n\nexport const assignNativeAudioNodeOptions = (nativeAudioNode: TNativeAudioNode, options: IAudioNodeOptions): void => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n", "import { TNativeAnalyserNode } from '../types';\n\nexport const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode: TNativeAnalyserNode): boolean => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n", "import { TNativeAnalyserNode } from '../types';\n\nexport const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode: TNativeAnalyserNode): void => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array: Float32Array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n\n        return array;\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nimport { TNativeAnalyserNodeFactoryFactory } from '../types';\n\nexport const createNativeAnalyserNodeFactory: TNativeAnalyserNodeFactoryFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (\n            !cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () =>\n                testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode)\n            )\n        ) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n\n        return nativeAnalyserNode;\n    };\n};\n", "import { TNativeAudioBufferConstructorFactory } from '../types';\n\nexport const createNativeAudioBufferConstructor: TNativeAudioBufferConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n\n    return null;\n};\n", "export const assignNativeAudioNodeAudioParamValue = <T extends { [key: string]: any }, U extends { [key: string]: any }>(\n    nativeAudioNode: T,\n    options: U,\n    audioParam: keyof T & keyof U\n) => {\n    const value = options[audioParam];\n\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n", "import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n\n        return (when = 0, offset = 0, duration?: number) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n", "import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            (<(when: number, offset: number, duration?: number) => void>start).call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n", "import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeAudioBufferSourceNodeFactory: TNativeAudioBufferSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClampling,\n    wrapAudioBufferSourceNodeStopMethodNullifiedBuffer,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n\n        // Bug #149: Safari does not yet support the detune AudioParam.\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () =>\n                testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () =>\n                testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () =>\n                testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n\n        return nativeAudioBufferSourceNode;\n    };\n};\n", "import { TNativeAudioContextConstructorFactory } from '../types';\n\nexport const createNativeAudioContextConstructor: TNativeAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n\n    return window.hasOwnProperty('webkitAudioContext') ? (<any>window).webkitAudioContext : null;\n};\n", "import { TNativeAudioDestinationNode, TNativeAudioDestinationNodeFactoryFactory, TNativeGainNode } from '../types';\n\nexport const createNativeAudioDestinationNodeFactory: TNativeAudioDestinationNodeFactoryFactory = (\n    createNativeGainNode,\n    overwriteAccessors\n) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            } catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n\n        overwriteAccessors(\n            gainNode,\n            'channelCount',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n\n                try {\n                    nativeAudioDestinationNode.channelCount = value;\n                } catch (err) {\n                    // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                    if (value > nativeAudioDestinationNode.maxChannelCount) {\n                        throw err;\n                    }\n                }\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelCountMode',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelCountMode = value;\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelInterpretation',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelInterpretation = value;\n            }\n        );\n\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n\n        return <{ maxChannelCount: TNativeAudioDestinationNode['maxChannelCount'] } & TNativeGainNode>gainNode;\n    };\n};\n", "import { TNativeAudioWorkletNodeConstructorFactory } from '../types';\n\nexport const createNativeAudioWorkletNodeConstructor: TNativeAudioWorkletNodeConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n", "import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): void => {\n    const { port1 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n    }\n};\n", "import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nimport { TNativeAudioWorkletNode, TNativeAudioWorkletNodeFactoryFactory, TNativeAudioWorkletNodeOptions } from '../types';\n\nexport const createNativeAudioWorkletNodeFactory: TNativeAudioWorkletNodeFactoryFactory = (\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(\n                    nativeContext,\n                    name,\n                    <TNativeAudioWorkletNodeOptions>options\n                );\n                const patchedEventListeners: Map<\n                    EventListenerOrEventListenerObject,\n                    NonNullable<TNativeAudioWorkletNode['onprocessorerror']>\n                > = new Map();\n\n                let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n\n                            onprocessorerror = typeof value === 'function' ? value : null;\n\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener =\n                                typeof args[1] === 'function'\n                                    ? args[1]\n                                    : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                } else {\n                                    args[1] = (event: Event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n\n                                            unpatchedEventListener(event);\n                                        } else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args: any[]): void => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n\n                                args[1] = patchedEventListener;\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n\n                return nativeAudioWorkletNode;\n            } catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n        }\n\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n\n        testClonabilityOfAudioWorkletNodeOptions(options);\n\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n", "export const computeBufferSize = (baseLatency: null | number, sampleRate: number) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n", "import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): Promise<IAudioWorkletNodeOptions> => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            reject(data);\n        };\n\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n", "import { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\n\nexport const createAudioWorkletProcessorPromise = async (\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n", "import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TNativeAudioWorkletNode, TNativeContext } from '../types';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\n\nexport const createAudioWorkletProcessor = (\n    nativeContext: TNativeContext,\n    nativeAudioWorkletNode: TNativeAudioWorkletNode,\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n\n    return audioWorkletProcessorPromise;\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { IAudioWorkletProcessor } from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeFakerFactoryFactory,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeConstantSourceNode,\n    TNativeGainNode\n} from '../types';\n\nexport const createNativeAudioWorkletNodeFakerFactory: TNativeAudioWorkletNodeFakerFactoryFactory = (\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters =\n            processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n\n        const messageChannel = new MessageChannel();\n        const gainNodes: TNativeGainNode[] = [];\n        const inputChannelSplitterNodes: TNativeChannelSplitterNode[] = [];\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(\n                createNativeGainNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                })\n            );\n            inputChannelSplitterNodes.push(\n                createNativeChannelSplitterNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                })\n            );\n        }\n\n        const constantSourceNodes: TNativeConstantSourceNode[] = [];\n\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset:\n                        options.parameterData[name] !== undefined\n                            ? options.parameterData[name]\n                            : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(\n            nativeContext,\n            bufferSize,\n            numberOfInputChannels + numberOfParameters,\n            // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n            Math.max(1, numberOfOutputChannels)\n        );\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(\n                createNativeChannelMergerNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                })\n            );\n        }\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n\n        const parameterMap = new ReadOnlyMap(\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                      const constantSourceNode = constantSourceNodes[index];\n\n                      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                      constantSourceNode.start(0);\n\n                      return <[string, TNativeAudioParam]>[name, constantSourceNode.offset];\n                  })\n        );\n\n        inputChannelMergerNode.connect(scriptProcessorNode);\n\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode(): TNativeAudioWorkletNode['channelCountMode'] {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation(): TNativeAudioWorkletNode['channelInterpretation'] {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n\n                channelInterpretation = value;\n            },\n            get context(): TNativeAudioWorkletNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return gainNodes;\n            },\n            get numberOfInputs(): number {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror(): TNativeAudioWorkletNode['onprocessorerror'] {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n\n                onprocessorerror = typeof value === 'function' ? value : null;\n\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters(): TNativeAudioWorkletNode['parameters'] {\n                return parameterMap;\n            },\n            get port(): TNativeAudioWorkletNode['port'] {\n                return messageChannel.port2;\n            },\n            addEventListener(...args: any[]): void {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        const patchedEventListeners: Map<EventListenerOrEventListenerObject, NonNullable<MessagePort['onmessage']>> = new Map();\n\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener =\n                        typeof args[1] === 'function'\n                            ? args[1]\n                            : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                        if (patchedEventListener !== undefined) {\n                            args[1] = <EventListenerOrEventListenerObject>patchedEventListener;\n                        } else {\n                            args[1] = (event: Event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                                    unpatchedEventListener(event)\n                                );\n                            };\n\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args: any[]): void => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n\n                        args[1] = patchedEventListener;\n                    }\n                }\n\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n\n        let onmessage: MessagePort['onmessage'] = null;\n\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n\n                onmessage = typeof value === 'function' ? value : null;\n\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n\n        processorConstructor.prototype.port = messageChannel.port1;\n\n        let audioWorkletProcessor: null | IAudioWorkletProcessor = null;\n\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(\n            nativeContext,\n            nativeAudioWorkletNodeFaker,\n            processorConstructor,\n            options\n        );\n\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters: { [name: string]: Float32Array } =\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.reduce(\n                      (prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n                      {}\n                  );\n\n        let isActive = true;\n\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n\n        const activeInputIndexes = new Map<number, number>();\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }: AudioProcessingEvent) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n\n                                return input;\n                            }\n\n                            const count = activeInputIndexes.get(index);\n\n                            if (count === undefined) {\n                                return [];\n                            }\n\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                } else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n\n                            return input;\n                        });\n\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                            nativeContext.currentTime + i / nativeContext.sampleRate,\n                            nativeContext.sampleRate,\n                            () => (<IAudioWorkletProcessor>audioWorkletProcessor).process(potentiallyEmptyInputs, outputs, parameters)\n                        );\n\n                        isActive = activeSourceFlag;\n\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    } catch (error) {\n                        isActive = false;\n\n                        nativeAudioWorkletNodeFaker.dispatchEvent(\n                            new ErrorEvent('processorerror', {\n                                colno: error.colno,\n                                filename: error.filename,\n                                lineno: error.lineno,\n                                message: error.message\n                            })\n                        );\n                    }\n\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        } else {\n                            disconnectFakeGraph();\n                        }\n\n                        break;\n                    }\n                }\n            }\n        };\n\n        let isConnected = false;\n\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n\n            isConnected = false;\n        };\n\n        connectFakeGraph();\n\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeBiquadFilterNodeFactory } from '../types';\n\nexport const createNativeBiquadFilterNode: TNativeBiquadFilterNodeFactory = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n\n    return nativeBiquadFilterNode;\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeChannelMergerNodeFactoryFactory } from '../types';\n\nexport const createNativeChannelMergerNodeFactory: TNativeChannelMergerNodeFactoryFactory = (\n    nativeAudioContextConstructor,\n    wrapChannelMergerNode\n) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n\n        return nativeChannelMergerNode;\n    };\n};\n", "import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeChannelSplitterNode } from '../types';\n\nexport const wrapChannelSplitterNode = (channelSplitterNode: TNativeChannelSplitterNode): void => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nimport { TNativeChannelSplitterNodeFactory } from '../types';\n\nexport const createNativeChannelSplitterNode: TNativeChannelSplitterNodeFactory = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n\n    return nativeChannelSplitterNode;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeConstantSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeConstantSourceNodeFactory: TNativeConstantSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n\n        return nativeConstantSourceNode;\n    };\n};\n", "import { TNativeAudioNode } from '../types';\n\nexport const interceptConnections = <T extends object>(\n    original: T,\n    interceptor: TNativeAudioNode\n): T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] } => {\n    (<T & { connect: TNativeAudioNode['connect'] }>original).connect = interceptor.connect.bind(interceptor);\n\n    (<T & { disconnect: TNativeAudioNode['disconnect'] }>original).disconnect = interceptor.disconnect.bind(interceptor);\n\n    return <T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] }>original;\n};\n", "import { interceptConnections } from '../helpers/intercept-connections';\nimport {\n    TNativeAudioBufferSourceNode,\n    TNativeAudioNode,\n    TNativeConstantSourceNode,\n    TNativeConstantSourceNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeConstantSourceNodeFakerFactory: TNativeConstantSourceNodeFakerFactoryFactory = (\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeConstantSourceNode['channelCountMode'] {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeConstantSourceNode['channelInterpretation'] {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context(): TNativeConstantSourceNode['context'] {\n                return gainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [];\n            },\n            get numberOfInputs(): number {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return gainNode.numberOfOutputs;\n            },\n            get offset(): TNativeConstantSourceNode['offset'] {\n                return gainNode.gain;\n            },\n            get onended(): TNativeConstantSourceNode['onended'] {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = <TNativeAudioBufferSourceNode['onended']>value;\n            },\n            addEventListener(...args: any[]): void {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0): void {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0): void {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeConvolverNodeFactoryFactory } from '../types';\n\nexport const createNativeConvolverNodeFactory: TNativeConvolverNodeFactoryFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCount',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCountMode',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        return nativeConvolverNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDelayNodeFactory } from '../types';\n\nexport const createNativeDelayNode: TNativeDelayNodeFactory = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n\n    return nativeDelayNode;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDynamicsCompressorNodeFactoryFactory } from '../types';\n\nexport const createNativeDynamicsCompressorNodeFactory: TNativeDynamicsCompressorNodeFactoryFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n\n        return nativeDynamicsCompressorNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeGainNodeFactory } from '../types';\n\nexport const createNativeGainNode: TNativeGainNodeFactory = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n\n    return nativeGainNode;\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeIIRFilterNodeFactoryFactory } from '../types';\n\nexport const createNativeIIRFilterNodeFactory: TNativeIIRFilterNodeFactoryFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(<number[]>options.feedforward, <number[]>options.feedback);\n\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n\n        return nativeIIRFilterNode;\n    };\n};\n", "import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeIIRFilterNode, TNativeIIRFilterNodeFakerFactoryFactory } from '../types';\n\nfunction divide(a: [number, number], b: [number, number]): [number, number] {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a: [number, number], b: [number, number]): [number, number] {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient: Float64Array, z: [number, number]): [number, number] {\n    let result: [number, number] = [0, 0];\n\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n\n        result[0] += coefficient[i];\n    }\n\n    return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory: TNativeIIRFilterNodeFakerFactoryFactory = (\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n\n        const bufferLength = 32;\n        const bufferIndexes: number[] = [];\n        const xBuffers: Float32Array[] = [];\n        const yBuffers: Float32Array[] = [];\n\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event: AudioProcessingEvent) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n\n            const numberOfChannels = inputBuffer.numberOfChannels;\n\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n\n                bufferIndexes[i] = filterBuffer(\n                    convertedFeedback,\n                    feedbackLength,\n                    convertedFeedforward,\n                    feedforwardLength,\n                    minLength,\n                    xBuffers[i],\n                    yBuffers[i],\n                    bufferIndexes[i],\n                    bufferLength,\n                    input,\n                    output\n                );\n            }\n        };\n\n        const nyquist = nativeContext.sampleRate / 2;\n\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeIIRFilterNode['channelCountMode'] {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeIIRFilterNode['channelInterpretation'] {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context(): TNativeIIRFilterNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs(): number {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args: any[]): void {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n\n                const length = frequencyHz.length;\n\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z: [number, number] = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n", "import { TNativeMediaElementAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNodeFactory = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeMediaStreamAudioDestinationNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNodeFactory = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n};\n", "import { TNativeMediaStreamAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNodeFactory = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n\n    return nativeMediaStreamAudioSourceNode;\n};\n", "import { TNativeMediaStreamTrackAudioSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeMediaStreamTrackAudioSourceNodeFactory: TNativeMediaStreamTrackAudioSourceNodeFactoryFactory = (\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n", "import { TNativeOfflineAudioContextConstructorFactory } from '../types';\n\nexport const createNativeOfflineAudioContextConstructor: TNativeOfflineAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? (<any>window).webkitOfflineAudioContext : null;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeOscillatorNodeFactoryFactory } from '../types';\n\nexport const createNativeOscillatorNodeFactory: TNativeOscillatorNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n\n        return nativeOscillatorNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativePannerNodeFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFactory: TNativePannerNodeFactoryFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n\n        return nativePannerNode;\n    };\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativePannerNode, TNativePannerNodeFakerFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFakerFactory: TNativePannerNodeFakerFactoryFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n) => {\n    return (\n        nativeContext,\n        {\n            coneInnerAngle,\n            coneOuterAngle,\n            coneOuterGain,\n            distanceModel,\n            maxDistance,\n            orientationX,\n            orientationY,\n            orientationZ,\n            panningModel,\n            positionX,\n            positionY,\n            positionZ,\n            refDistance,\n            rolloffFactor,\n            ...audioNodeOptions\n        }\n    ) => {\n        const pannerNode = nativeContext.createPanner();\n\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        } as const;\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n\n        let lastOrientation: [number, number, number] = [orientationX, orientationY, orientationZ];\n        let lastPosition: [number, number, number] = [positionX, positionY, positionZ];\n\n        const buffer = new Float32Array(1);\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 0),\n                getFirstSample(inputBuffer, buffer, 1),\n                getFirstSample(inputBuffer, buffer, 2)\n            ];\n\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                lastOrientation = orientation;\n            }\n\n            const positon: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 3),\n                getFirstSample(inputBuffer, buffer, 4),\n                getFirstSample(inputBuffer, buffer, 5)\n            ];\n\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n                lastPosition = positon;\n            }\n        };\n\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n\n        const nativePannerNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode(): TNativePannerNode['channelCountMode'] {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativePannerNode['channelInterpretation'] {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle(): TNativePannerNode['coneInnerAngle'] {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle(): TNativePannerNode['coneOuterAngle'] {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain(): TNativePannerNode['coneOuterGain'] {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n\n                pannerNode.coneOuterGain = value;\n            },\n            get context(): TNativePannerNode['context'] {\n                return pannerNode.context;\n            },\n            get distanceModel(): TNativePannerNode['distanceModel'] {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get maxDistance(): TNativePannerNode['maxDistance'] {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs(): number {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX(): TNativePannerNode['orientationX'] {\n                return orientationXGainNode.gain;\n            },\n            get orientationY(): TNativePannerNode['orientationY'] {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ(): TNativePannerNode['orientationZ'] {\n                return orientationZGainNode.gain;\n            },\n            get panningModel(): TNativePannerNode['panningModel'] {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX(): TNativePannerNode['positionX'] {\n                return positionXGainNode.gain;\n            },\n            get positionY(): TNativePannerNode['positionY'] {\n                return positionYGainNode.gain;\n            },\n            get positionZ(): TNativePannerNode['positionZ'] {\n                return positionZGainNode.gain;\n            },\n            get refDistance(): TNativePannerNode['refDistance'] {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor(): TNativePannerNode['rolloffFactor'] {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { TNativePeriodicWaveFactoryFactory } from '../types';\n\nexport const createNativePeriodicWaveFactory: TNativePeriodicWaveFactoryFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n\n        return nativePeriodicWave;\n    };\n};\n", "import { TNativeScriptProcessorNodeFactory } from '../types';\n\nexport const createNativeScriptProcessorNode: TNativeScriptProcessorNodeFactory = (\n    nativeContext,\n    bufferSize,\n    numberOfInputChannels,\n    numberOfOutputChannels\n) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeStereoPannerNodeFactoryFactory } from '../types';\n\nexport const createNativeStereoPannerNodeFactory: TNativeStereoPannerNodeFactoryFactory = (\n    createNativeStereoPannerNodeFaker,\n    createNotSupportedError\n) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n\n        return nativeStereoPannerNode;\n    };\n};\n", "import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeWaveShaperNodeFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFactory: TNativeWaveShaperNodeFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined\n        ) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n\n        overwriteAccessors(\n            nativeWaveShaperNode,\n            'curve',\n            (get) => () => get.call(nativeWaveShaperNode),\n            (set) => (value) => {\n                set.call(nativeWaveShaperNode, value);\n\n                if (isConnected) {\n                    if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(\n                            nativeContext,\n                            nativeWaveShaperNode\n                        );\n                    } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n\n                return value;\n            }\n        );\n\n        const whenConnected = () => {\n            isConnected = true;\n\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => new DOMException('', 'NotSupportedError');\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TNativeOfflineAudioContext, TOfflineAudioContextConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createOfflineAudioContextConstructor: TOfflineAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor<IOfflineAudioContext> implements IOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions);\n        constructor(numberOfChannels: number, length: number, sampleRate: number);\n        constructor(a: number | IOfflineAudioContextOptions, b?: number, c?: number) {\n            let options: IOfflineAudioContextOptions;\n\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            } else if (typeof a === 'object') {\n                options = a;\n            } else {\n                throw new Error('The given parameters are not valid.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n", "import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport {\n    IAudioParam,\n    IAudioScheduledSourceNodeEventMap,\n    IMinimalOfflineAudioContext,\n    IOscillatorNode,\n    IOscillatorNodeRenderer,\n    IOscillatorOptions\n} from '../interfaces';\nimport {\n    TContext,\n    TEventHandler,\n    TNativeOscillatorNode,\n    TOscillatorNodeConstructorFactory,\n    TOscillatorNodeRenderer,\n    TOscillatorType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max', // This attribute has no effect for nodes with no inputs.\n    channelInterpretation: 'speakers', // This attribute has no effect for nodes with no inputs.\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n} as const;\n\nexport const createOscillatorNodeConstructor: TOscillatorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class OscillatorNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IOscillatorNode<T>\n    {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _nativeOscillatorNode: TNativeOscillatorNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _oscillatorNodeRenderer: TOscillatorNodeRenderer<T>;\n\n        constructor(context: T, options?: Partial<IOscillatorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = <TOscillatorNodeRenderer<T>>(isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                (<IOscillatorNodeRenderer<IMinimalOfflineAudioContext>>this._oscillatorNodeRenderer).periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeOscillatorNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get type(): TOscillatorType {\n            return this._nativeOscillatorNode.type;\n        }\n\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n\n        public setPeriodicWave(periodicWave: PeriodicWave): void {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n\n        public start(when = 0): void {\n            this._nativeOscillatorNode.start(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeOscillatorNode.stop(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IOscillatorNode, IPeriodicWave } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeOscillatorNode, TOscillatorNodeRendererFactoryFactory } from '../types';\n\nexport const createOscillatorNodeRendererFactory: TOscillatorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeOscillatorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeOscillatorNode>();\n\n        let periodicWave: null | IPeriodicWave = null;\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createOscillatorNode = async (proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode<T, TNativeOscillatorNode>(proxy);\n\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n\n            return nativeOscillatorNode;\n        };\n\n        return {\n            set periodicWave(value: null | IPeriodicWave) {\n                periodicWave = value;\n            },\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeOscillatorNode> {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IPannerNode, IPannerOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TContext,\n    TDistanceModelType,\n    TNativePannerNode,\n    TPannerNodeConstructorFactory,\n    TPanningModelType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n} as const;\n\nexport const createPannerNodeConstructor: TPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class PannerNode<T extends TContext> extends audioNodeConstructor<T> implements IPannerNode<T> {\n        private _nativePannerNode: TNativePannerNode;\n\n        private _orientationX: IAudioParam;\n\n        private _orientationY: IAudioParam;\n\n        private _orientationZ: IAudioParam;\n\n        private _positionX: IAudioParam;\n\n        private _positionY: IAudioParam;\n\n        private _positionZ: IAudioParam;\n\n        constructor(context: T, options?: Partial<IPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createPannerNodeRenderer() : null);\n\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get coneInnerAngle(): number {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n\n        get coneOuterAngle(): number {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n\n        get coneOuterGain(): number {\n            return this._nativePannerNode.coneOuterGain;\n        }\n\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n\n        get distanceModel(): TDistanceModelType {\n            return this._nativePannerNode.distanceModel;\n        }\n\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n\n        get maxDistance(): number {\n            return this._nativePannerNode.maxDistance;\n        }\n\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n\n        get orientationX(): IAudioParam {\n            return this._orientationX;\n        }\n\n        get orientationY(): IAudioParam {\n            return this._orientationY;\n        }\n\n        get orientationZ(): IAudioParam {\n            return this._orientationZ;\n        }\n\n        get panningModel(): TPanningModelType {\n            return this._nativePannerNode.panningModel;\n        }\n\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n\n        get positionX(): IAudioParam {\n            return this._positionX;\n        }\n\n        get positionY(): IAudioParam {\n            return this._positionY;\n        }\n\n        get positionZ(): IAudioParam {\n            return this._positionZ;\n        }\n\n        get refDistance(): number {\n            return this._nativePannerNode.refDistance;\n        }\n\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n\n        get rolloffFactor(): number {\n            return this._nativePannerNode.rolloffFactor;\n        }\n\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, INativePannerNodeFaker, IOfflineAudioContext, IPannerNode } from '../interfaces';\nimport {\n    TNativeAudioBuffer,\n    TNativeGainNode,\n    TNativeOfflineAudioContext,\n    TNativePannerNode,\n    TPannerNodeRendererFactoryFactory\n} from '../types';\n\nexport const createPannerNodeRendererFactory: TPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode | TNativePannerNode>();\n\n        let renderedBufferPromise: null | Promise<TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode: null | TNativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode<T, TNativePannerNode>(proxy);\n\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            } else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        6,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all(\n                            [\n                                proxy.orientationX,\n                                proxy.orientationY,\n                                proxy.orientationZ,\n                                proxy.positionX,\n                                proxy.positionY,\n                                proxy.positionZ\n                            ].map(async (audioParam, index) => {\n                                const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: index === 0 ? 1 : 0\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n\n                                return nativeConstantSourceNode;\n                            })\n                        );\n\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n\n                const channelDatas: Float32Array[] = [];\n\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n\n                inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation: [number, number, number] = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon: [number, number, number] = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n                    if (\n                        orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])\n                    ) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n\n                        inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n\n                return nativeGainNode;\n            }\n\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n\n            return nativePannerNode;\n        };\n\n        return {\n            render(\n                proxy: IPannerNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeGainNode | TNativePannerNode> {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IPeriodicWave, IPeriodicWaveOptions } from '../interfaces';\nimport { TContext, TPeriodicWaveConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n} as const;\n\nexport const createPeriodicWaveConstructor: TPeriodicWaveConstructorFactory = (\n    createNativePeriodicWave,\n    getNativeContext,\n    periodicWaveStore,\n    sanitizePeriodicWaveOptions\n) => {\n    return class PeriodicWave<T extends TContext> implements IPeriodicWave {\n        constructor(context: T, options?: Partial<IPeriodicWaveOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n\n            periodicWaveStore.add(periodicWave);\n\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(<any>instance)\n            );\n        }\n    };\n};\n", "import { TRenderAutomationFactory } from '../types';\n\nexport const createRenderAutomation: TRenderAutomationFactory = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n\n        audioParamRenderer.replay(nativeAudioParam);\n\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n", "import { IAudioParam, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TNativeAudioParam, TNativeOfflineAudioContext, TRenderInputsOfAudioParamFactory } from '../types';\n\nexport const createRenderInputsOfAudioParam: TRenderInputsOfAudioParamFactory = (\n    getAudioNodeRenderer,\n    getAudioParamConnections,\n    isPartOfACycle\n) => {\n    return async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioParam: IAudioParam,\n        nativeOfflineAudioContext: TNativeOfflineAudioContext,\n        nativeAudioParam: TNativeAudioParam\n    ): Promise<void> => {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        await Promise.all(\n            Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n                const audioNodeRenderer = getAudioNodeRenderer(source);\n                const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n\n                if (!isPartOfACycle(source)) {\n                    renderedNativeAudioNode.connect(nativeAudioParam, output);\n                }\n            })\n        );\n    };\n};\n", "import { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IOfflineAudioCompletionEvent } from '../interfaces';\nimport { TNativeAudioBuffer, TRenderNativeOfflineAudioContextFactory } from '../types';\n\nexport const createRenderNativeOfflineAudioContext: TRenderNativeOfflineAudioContextFactory = (\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    testOfflineAudioContextCurrentTimeSupport\n) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(\n                cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)\n            ).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n\n        return new Promise<TNativeAudioBuffer>((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n\n            nativeOfflineAudioContext.oncomplete = (event: IOfflineAudioCompletionEvent) => {\n                gainNode.disconnect();\n\n                resolve(event.renderedBuffer);\n            };\n\n            gainNode.connect(nativeOfflineAudioContext.destination);\n\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n", "import { TSetActiveAudioWorkletNodeInputsFactory } from '../types';\n\nexport const createSetActiveAudioWorkletNodeInputs: TSetActiveAudioWorkletNodeInputsFactory = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n", "import { TSetAudioNodeTailTimeFactory } from '../types';\n\nexport const createSetAudioNodeTailTime: TSetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n", "import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TStartRenderingFactory } from '../types';\n\nexport const createStartRendering: TStartRenderingFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (destination, nativeOfflineAudioContext) =>\n        getAudioNodeRenderer(destination)\n            .render(destination, nativeOfflineAudioContext)\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n             * destination.\n             */\n            .then(() =>\n                Promise.all(\n                    Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) =>\n                        getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)\n                    )\n                )\n            )\n            .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n            .then((audioBuffer) => {\n                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                if (typeof audioBuffer.copyFromChannel !== 'function') {\n                    wrapAudioBufferCopyChannelMethods(audioBuffer);\n                    wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                } else if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n};\n", "import { IAudioParam, IStereoPannerNode, IStereoPannerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TStereoPannerNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n} as const;\n\nexport const createStereoPannerNodeConstructor: TStereoPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class StereoPannerNode<T extends TContext> extends audioNodeConstructor<T> implements IStereoPannerNode<T> {\n        private _pan: IAudioParam;\n\n        constructor(context: T, options?: Partial<IStereoPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createStereoPannerNodeRenderer() : null);\n\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n\n        get pan(): IAudioParam {\n            return this._pan;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IStereoPannerNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeStereoPannerNode, TStereoPannerNodeRendererFactoryFactory } from '../types';\n\nexport const createStereoPannerNodeRendererFactory: TStereoPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeStereoPannerNodes = new WeakMap<TNativeOfflineAudioContext, TNativeStereoPannerNode>();\n\n        const createStereoPannerNode = async (proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode<T, TNativeStereoPannerNode>(proxy);\n\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n\n            return nativeStereoPannerNode;\n        };\n\n        return {\n            render(proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeStereoPannerNode> {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TTestAudioBufferConstructorSupportFactory } from '../types';\n\n// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport: TTestAudioBufferConstructorSupportFactory = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n", "import { TTestAudioWorkletProcessorPostMessageSupportFactory } from '../types';\n\n// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport: TTestAudioWorkletProcessorPostMessageSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            ['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n\n            // Bug #197: Safari does not deliver the messages before the promise returned by startRendering() resolves.\n            await new Promise((resolve) => setTimeout(resolve));\n        } catch {\n            // Ignore errors.\n        } finally {\n            URL.revokeObjectURL(url);\n        }\n\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n", "import { TTestOfflineAudioContextCurrentTimeSupportFactory } from '../types';\n\nexport const createTestOfflineAudioContextCurrentTimeSupport: TTestOfflineAudioContextCurrentTimeSupportFactory = (\n    createNativeGainNode,\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n", "import { TUnknownErrorFactory } from '../types';\n\nexport const createUnknownError: TUnknownErrorFactory = () => new DOMException('', 'UnknownError');\n", "import { IWaveShaperNode, IWaveShaperOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TNativeWaveShaperNode, TOverSampleType, TWaveShaperNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n} as const;\n\nexport const createWaveShaperNodeConstructor: TWaveShaperNodeConstructorFactory = (\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class WaveShaperNode<T extends TContext> extends audioNodeConstructor<T> implements IWaveShaperNode<T> {\n        private _isCurveNullified: boolean;\n\n        private _nativeWaveShaperNode: TNativeWaveShaperNode;\n\n        constructor(context: T, options?: Partial<IWaveShaperOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createWaveShaperNodeRenderer() : null);\n\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get curve(): null | Float32Array {\n            if (this._isCurveNullified) {\n                return null;\n            }\n\n            return this._nativeWaveShaperNode.curve;\n        }\n\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n\n        get oversample(): TOverSampleType {\n            return this._nativeWaveShaperNode.oversample;\n        }\n\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TWindow, TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n", "import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethods: TWrapAudioBufferCopyChannelMethodsFactory = (\n    convertNumberToUnsignedLong,\n    createIndexSizeError\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n", "import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethodsOutOfBounds: TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory = (\n    convertNumberToUnsignedLong\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n", "import { TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory } from '../types';\n\nexport const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer: TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory = (\n    overwriteAccessors\n) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n\n        overwriteAccessors(\n            nativeAudioBufferSourceNode,\n            'buffer',\n            (get) => () => {\n                const value = get.call(nativeAudioBufferSourceNode);\n\n                return value === nullifiedBuffer ? null : value;\n            },\n            (set) => (value) => {\n                return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n            }\n        );\n    };\n};\n", "import { TWrapChannelMergerNodeFactory } from '../types';\n\nexport const createWrapChannelMergerNode: TWrapChannelMergerNodeFactory = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n", "import { TGetFirstSampleFunction } from '../types';\n\nexport const getFirstSample: TGetFirstSampleFunction = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n\n    return buffer[0];\n};\n", "import { TIsDCCurveFunction } from '../types';\n\nexport const isDCCurve: TIsDCCurveFunction = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n\n    const length = curve.length;\n\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n", "import { TOverwriteAccessorsFunction } from '../types';\n\nexport const overwriteAccessors: TOverwriteAccessorsFunction = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n\n    const { get, set } = <Required<PropertyDescriptor>>Object.getOwnPropertyDescriptor(prototype, property);\n\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n", "import { TSanitizeAudioWorkletNodeOptionsFunction } from '../types';\n\nexport const sanitizeAudioWorkletNodeOptions: TSanitizeAudioWorkletNodeOptionsFunction = (options) => {\n    return {\n        ...options,\n        outputChannelCount:\n            options.outputChannelCount !== undefined\n                ? options.outputChannelCount\n                : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                  [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n", "import { TSanitizeChannelSplitterOptionsFunction } from '../types';\n\nexport const sanitizeChannelSplitterOptions: TSanitizeChannelSplitterOptionsFunction = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n", "import { TSanitizePeriodicWaveOptionsFunction } from '../types';\n\nexport const sanitizePeriodicWaveOptions: TSanitizePeriodicWaveOptionsFunction = (options) => {\n    const { imag, real } = options;\n\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n\n    return { ...options, imag, real };\n};\n", "import { TSetValueAtTimeUntilPossibleFunction } from '../types';\n\nexport const setValueAtTimeUntilPossible: TSetValueAtTimeUntilPossibleFunction = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    } catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.start();\n    } catch {\n        return true;\n    }\n\n    return false;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n\n        return true;\n    } catch {\n        return false;\n    }\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n", "import { TTestAudioWorkletNodeOptionsClonabilityFunction } from '../types';\n\nexport const testAudioWorkletNodeOptionsClonability: TTestAudioWorkletNodeOptionsClonabilityFunction = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n        port2.close();\n    }\n};\n", "import { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            } else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n", "import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n", "import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n", "import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport {\n    AudioBuffer,\n    AudioBufferSourceNode,\n    AudioWorkletNode,\n    IAudioBuffer,\n    IMinimalAudioContext,\n    MediaStreamAudioSourceNode,\n    MinimalAudioContext,\n    addAudioWorkletModule\n} from 'standardized-audio-context';\nimport { IAudioNodesAndEncoderId } from '../interfaces';\nimport { TRecordingState, TWebAudioMediaRecorderFactoryFactory } from '../types';\n\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (\n    audioBuffer: IAudioBuffer,\n    audioContext: IMinimalAudioContext,\n    channelCount: number,\n    mediaStream: MediaStream,\n    mimeType: string\n) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\n\nexport const createWebAudioMediaRecorderFactory: TWebAudioMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        const sampleRate = mediaStream.getAudioTracks()[0]?.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url: string) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n\n            return addAudioWorkletModule(audioContext, url);\n        });\n\n        let abortRecording: null | (() => void) = null;\n        let intervalId: null | number = null;\n        let promisedAudioNodesAndEncoderId: null | Promise<IAudioNodesAndEncoderId> = null;\n        let promisedPartialRecording: null | Promise<void> = null;\n        let isAudioContextRunning = true;\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const resume = (): Promise<void> => {\n            isAudioContextRunning = true;\n\n            return audioContext.resume();\n        };\n\n        const stop = (): void => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n\n            promisedAudioNodesAndEncoderId.then(async ({ encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(() => {\n                        /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                }\n\n                await recorderAudioWorkletNode.stop();\n\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n\n                const arrayBuffers = await encode(encoderId, null);\n\n                if (promisedAudioNodesAndEncoderId === null) {\n                    await suspend();\n                }\n\n                dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                bufferedArrayBuffers.length = 0;\n\n                eventTarget.dispatchEvent(new Event('stop'));\n            });\n\n            promisedAudioNodesAndEncoderId = null;\n        };\n\n        const suspend = (): Promise<void> => {\n            isAudioContextRunning = false;\n\n            return audioContext.suspend();\n        };\n\n        suspend();\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n\n            pause(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n\n            resume(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n\n            start(timeslice?: number): void {\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                eventTarget.dispatchEvent(new Event('start'));\n\n                const audioTracks = mediaStream.getAudioTracks();\n                const channelCount = audioTracks.length === 0 ? 2 : audioTracks[0].getSettings().channelCount ?? 2;\n\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() =>\n                        createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType)\n                    )\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n\n                    await recorderAudioWorkletNode.record(port);\n\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return { encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n\n                const tracks = mediaStream.getTracks();\n\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n\n                    if (\n                        (currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null\n                    ) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n\n            stop\n        };\n    };\n};\n", "import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nimport { TPromisedDataViewElementTypeEncoderIdAndPort, TRecordingState, TWebmPcmMediaRecorderFactoryFactory } from '../types';\n\nexport const createWebmPcmMediaRecorderFactory: TWebmPcmMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    decodeWebMChunk,\n    readVariableSizeInteger\n) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n\n        let promisedPartialRecording: null | Promise<void> = null;\n        let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const stop = (): void => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n\n            stopRecording();\n            stopRecording = () => {}; // tslint:disable-line:no-empty\n\n            nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', (event) => {\n            stop();\n            eventTarget.dispatchEvent(\n                new ErrorEvent('error', {\n                    error: (<ErrorEvent>event).error\n                })\n            );\n        });\n        nativeMediaRecorder.addEventListener('pause', () => eventTarget.dispatchEvent(new Event('pause')));\n        nativeMediaRecorder.addEventListener('resume', () => eventTarget.dispatchEvent(new Event('resume')));\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return nativeMediaRecorder.state;\n            },\n\n            pause(): void {\n                return nativeMediaRecorder.pause();\n            },\n\n            resume(): void {\n                return nativeMediaRecorder.resume();\n            },\n\n            start(timeslice?: number): void {\n                const [audioTrack] = mediaStream.getAudioTracks();\n\n                if (audioTrack !== undefined && nativeMediaRecorder.state === 'inactive') {\n                    // Bug #19: Chrome does not expose the correct channelCount property right away.\n                    const { channelCount, sampleRate } = audioTrack.getSettings();\n\n                    if (channelCount === undefined) {\n                        throw new Error('The channelCount is not defined.');\n                    }\n\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort: TPromisedDataViewElementTypeEncoderIdAndPort = instantiate(\n                        mimeType,\n                        sampleRate\n                    );\n\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n\n                    const removeEventListener = on(\n                        nativeMediaRecorder,\n                        'dataavailable'\n                    )(({ data }) => {\n                        pendingInvocations += 1;\n\n                        const promisedArrayBuffer = data.arrayBuffer();\n\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(\n                            async ({ dataView = null, elementType = null, encoderId, port }) => {\n                                const arrayBuffer = await promisedArrayBuffer;\n\n                                pendingInvocations -= 1;\n\n                                const currentDataView =\n                                    dataView === null\n                                        ? new MultiBufferDataView([arrayBuffer])\n                                        : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n                                if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                    const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                                    if (lengthAndValue === null) {\n                                        return { dataView: currentDataView, elementType, encoderId, port };\n                                    }\n\n                                    const { value } = lengthAndValue;\n\n                                    if (value !== 172351395) {\n                                        return { dataView, elementType, encoderId, port };\n                                    }\n\n                                    isRecording = true;\n                                }\n\n                                const { currentElementType, offset, contents } = decodeWebMChunk(\n                                    currentDataView,\n                                    elementType,\n                                    channelCount\n                                );\n                                const remainingDataView =\n                                    offset < currentDataView.byteLength\n                                        ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                        : null;\n\n                                contents.forEach((content) =>\n                                    port.postMessage(\n                                        content,\n                                        content.map(({ buffer }) => buffer)\n                                    )\n                                );\n\n                                if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                    encode(encoderId, null).then((arrayBuffers) => {\n                                        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                                        bufferedArrayBuffers.length = 0;\n\n                                        eventTarget.dispatchEvent(new Event('stop'));\n                                    });\n\n                                    port.postMessage([]);\n                                    port.close();\n\n                                    removeEventListener();\n                                }\n\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                            }\n                        );\n                    });\n\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(\n                            ({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice))\n                        );\n                    }\n                }\n\n                nativeMediaRecorder.start(100);\n            },\n\n            stop\n        };\n    };\n};\n", "import { TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : window);\n", "import { TReadVariableSizeIntegerLengthFunction } from '../types';\n\nexport const readVariableSizeIntegerLength: TReadVariableSizeIntegerLengthFunction = (dataView, offset) => {\n    if (offset >= dataView.byteLength) {\n        return null;\n    }\n\n    const byte = dataView.getUint8(offset);\n\n    if (byte > 127) {\n        return 1;\n    }\n\n    if (byte > 63) {\n        return 2;\n    }\n\n    if (byte > 31) {\n        return 3;\n    }\n\n    if (byte > 15) {\n        return 4;\n    }\n\n    if (byte > 7) {\n        return 5;\n    }\n\n    if (byte > 3) {\n        return 6;\n    }\n\n    if (byte > 1) {\n        return 7;\n    }\n\n    if (byte > 0) {\n        return 8;\n    }\n\n    const length = readVariableSizeIntegerLength(dataView, offset + 1);\n\n    return length === null ? null : length + 8;\n};\n", "import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n", "import { register as rgstr } from 'media-encoder-host';\nimport { createBlobEventFactory } from './factories/blob-event-factory';\nimport { createDecodeWebMChunk } from './factories/decode-web-m-chunk';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createEventTargetFactory } from './factories/event-target-factory';\nimport { createInvalidModificationError } from './factories/invalid-modification-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaRecorderConstructor } from './factories/media-recorder-constructor';\nimport { createNativeBlobEventConstructor } from './factories/native-blob-event-constructor';\nimport { createNativeMediaRecorderConstructor } from './factories/native-media-recorder-constructor';\nimport { createNativeMediaRecorderFactory } from './factories/native-media-recorder-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createReadElementContent } from './factories/read-element-content';\nimport { createReadElementType } from './factories/read-element-type';\nimport { createReadVariableSizeInteger } from './factories/read-variable-size-integer';\nimport { createWebAudioMediaRecorderFactory } from './factories/web-audio-media-recorder';\nimport { createWebmPcmMediaRecorderFactory } from './factories/webm-pcm-media-recorder';\nimport { createWindow } from './factories/window';\nimport { readVariableSizeIntegerLength } from './functions/read-variable-size-integer-length';\nimport { wrapEventListener } from './functions/wrap-event-listener';\nimport { IMediaRecorderConstructor } from './interfaces';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst encoderRegexes: RegExp[] = [];\n\nconst window = createWindow();\nconst nativeBlobEventConstructor = createNativeBlobEventConstructor(window);\nconst createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);\nconst createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n);\nconst readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);\nconst readElementContent = createReadElementContent(readVariableSizeInteger);\nconst readElementType = createReadElementType(readVariableSizeInteger);\nconst decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);\nconst createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(createBlobEvent, decodeWebMChunk, readVariableSizeInteger);\nconst createEventTarget = createEventTargetFactory(window);\nconst nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window);\n\nconst mediaRecorderConstructor: IMediaRecorderConstructor = createMediaRecorderConstructor(\n    createNativeMediaRecorderFactory(createNotSupportedError),\n    createNotSupportedError,\n    createWebAudioMediaRecorder,\n    createWebmPcmMediaRecorder,\n    encoderRegexes,\n    createEventTargetConstructor(createEventTarget, wrapEventListener),\n    nativeMediaRecorderConstructor\n);\n\nexport { mediaRecorderConstructor as MediaRecorder };\n\nexport const isSupported = () => createIsSupportedPromise(window);\n\nexport const register = async (port: MessagePort): Promise<void> => {\n    encoderRegexes.push(await rgstr(port));\n};\n", "import { createBroker } from 'broker-factory';\nimport { TExtendableMediaRecorderWavEncoderWorkerDefinition } from 'extendable-media-recorder-wav-encoder-worker';\nimport { IExtendableMediaRecorderWavEncoderBrokerDefinition } from './interfaces';\nimport { TExtendableMediaRecorderWavEncoderBrokerLoader, TExtendableMediaRecorderWavEncoderBrokerWrapper } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nexport const wrap: TExtendableMediaRecorderWavEncoderBrokerWrapper = createBroker<\n    IExtendableMediaRecorderWavEncoderBrokerDefinition,\n    TExtendableMediaRecorderWavEncoderWorkerDefinition\n>({\n    characterize: ({ call }) => {\n        return () => call('characterize');\n    },\n    encode: ({ call }) => {\n        return (recordingId, timeslice) => {\n            return call('encode', { recordingId, timeslice });\n        };\n    },\n    record: ({ call }) => {\n        return async (recordingId, sampleRate, typedArrays) => {\n            await call(\n                'record',\n                { recordingId, sampleRate, typedArrays },\n                typedArrays.map(({ buffer }) => buffer)\n            );\n        };\n    }\n});\n\nexport const load: TExtendableMediaRecorderWavEncoderBrokerLoader = (url: string) => {\n    const worker = new Worker(url);\n\n    return wrap(worker);\n};\n", "// This is the minified and stringified code of the extendable-media-recorder-wav-encoder-worker package.\nexport const worker = `(()=>{var e={775:function(e,t,r){!function(e,t,r,n){\"use strict\";var o=function(e,t){return void 0===t?e:t.reduce((function(e,t){if(\"capitalize\"===t){var o=e.charAt(0).toUpperCase(),s=e.slice(1);return\"\".concat(o).concat(s)}return\"dashify\"===t?r(e):\"prependIndefiniteArticle\"===t?\"\".concat(n(e),\" \").concat(e):e}),e)},s=function(e){var t=e.name+e.modifiers.map((function(e){return\"\\\\\\\\.\".concat(e,\"\\\\\\\\(\\\\\\\\)\")})).join(\"\");return new RegExp(\"\\\\\\\\$\\\\\\\\{\".concat(t,\"}\"),\"g\")},a=function(e,r){for(var n=/\\\\\\${([^.}]+)((\\\\.[^(]+\\\\(\\\\))*)}/g,a=[],i=n.exec(e);null!==i;){var u={modifiers:[],name:i[1]};if(void 0!==i[3])for(var c=/\\\\.[^(]+\\\\(\\\\)/g,l=c.exec(i[2]);null!==l;)u.modifiers.push(l[0].slice(1,-2)),l=c.exec(i[2]);a.push(u),i=n.exec(e)}var d=a.reduce((function(e,n){return e.map((function(e){return\"string\"==typeof e?e.split(s(n)).reduce((function(e,s,a){return 0===a?[s]:n.name in r?[].concat(t(e),[o(r[n.name],n.modifiers),s]):[].concat(t(e),[function(e){return o(e[n.name],n.modifiers)},s])}),[]):[e]})).reduce((function(e,r){return[].concat(t(e),t(r))}),[])}),[e]);return function(e){return d.reduce((function(r,n){return[].concat(t(r),\"string\"==typeof n?[n]:[n(e)])}),[]).join(\"\")}},i=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=void 0===e.code?void 0:a(e.code,t),n=void 0===e.message?void 0:a(e.message,t);function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=arguments.length>1?arguments[1]:void 0,s=void 0===o&&(t instanceof Error||void 0!==t.code&&\"Exception\"===t.code.slice(-9))?{cause:t,missingParameters:{}}:{cause:o,missingParameters:t},a=s.cause,i=s.missingParameters,u=void 0===n?new Error:new Error(n(i));return null!==a&&(u.cause=a),void 0!==r&&(u.code=r(i)),void 0!==e.status&&(u.status=e.status),u}return o};e.compile=i}(t,r(106),r(881),r(507))},881:e=>{\"use strict\";e.exports=(e,t)=>{if(\"string\"!=typeof e)throw new TypeError(\"expected a string\");return e.trim().replace(/([a-z])([A-Z])/g,\"$1-$2\").replace(/\\\\W/g,(e=>/[\u00C0-\u017E]/.test(e)?e:\"-\")).replace(/^-+|-+$/g,\"\").replace(/-{2,}/g,(e=>t&&t.condense?\"-\":e)).toLowerCase()}},107:function(e,t){!function(e){\"use strict\";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),i=void 0===a?r.size:a<s?a+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*s);return e(r,i)}if(r.size>n)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,u=r(i),c=a(u,i),l=t(c);e.addUniqueNumber=l,e.generateUniqueNumber=c}(t)},507:e=>{var t=function(e){var t,r,n=/\\\\w+/.exec(e);if(!n)return\"an\";var o=(r=n[0]).toLowerCase(),s=[\"honest\",\"hour\",\"hono\"];for(t in s)if(0==o.indexOf(s[t]))return\"an\";if(1==o.length)return\"aedhilmnorsx\".indexOf(o)>=0?\"an\":\"a\";if(r.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/))return\"an\";var a=[/^e[uw]/,/^onc?e\\\\b/,/^uni([^nmd]|mo)/,/^u[bcfhjkqrst][aeiou]/];for(t=0;t<a.length;t++)if(o.match(a[t]))return\"a\";return r.match(/^U[NK][AIEO]/)?\"a\":r==r.toUpperCase()?\"aedhilmnorsx\".indexOf(o[0])>=0?\"an\":\"a\":\"aeiou\".indexOf(o[0])>=0||o.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/)?\"an\":\"a\"};void 0!==e.exports?e.exports=t:window.indefiniteArticle=t},768:e=>{e.exports=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n},e.exports.__esModule=!0,e.exports.default=e.exports},907:(e,t,r)=>{var n=r(768);e.exports=function(e){if(Array.isArray(e))return n(e)},e.exports.__esModule=!0,e.exports.default=e.exports},642:e=>{e.exports=function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)},e.exports.__esModule=!0,e.exports.default=e.exports},344:e=>{e.exports=function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")},e.exports.__esModule=!0,e.exports.default=e.exports},106:(e,t,r)=>{var n=r(907),o=r(642),s=r(906),a=r(344);e.exports=function(e){return n(e)||o(e)||s(e)||a()},e.exports.__esModule=!0,e.exports.default=e.exports},906:(e,t,r)=>{var n=r(768);e.exports=function(e,t){if(e){if(\"string\"==typeof e)return n(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?n(e,t):void 0}},e.exports.__esModule=!0,e.exports.default=e.exports}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{\"use strict\";var e=r(775);const t=-32603,n=-32602,o=-32601,s=(0,e.compile)({message:'The requested method called \"\\${method}\" is not supported.',status:o}),a=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned no required result.',status:t}),i=(0,e.compile)({message:'The handler of the method called \"\\${method}\" returned an unexpected result.',status:t}),u=(0,e.compile)({message:'The specified parameter called \"portId\" with the given value \"\\${portId}\" does not identify a port connected to this worker.',status:n});var c=r(107);const l=new Map,d=(e,t,r)=>({...t,connect:r=>{let{port:n}=r;n.start();const o=e(n,t),s=(0,c.generateUniqueNumber)(l);return l.set(s,(()=>{o(),n.close(),l.delete(s)})),{result:s}},disconnect:e=>{let{portId:t}=e;const r=l.get(t);if(void 0===r)throw u({portId:t.toString()});return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=r();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),f=function(e,t){const r=d(f,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0),n=((e,t)=>async r=>{let{data:{id:n,method:o,params:u}}=r;const c=t[o];try{if(void 0===c)throw s({method:o});const t=void 0===u?c():c(u);if(void 0===t)throw a({method:o});const r=t instanceof Promise?await t:t;if(null===n){if(void 0!==r.result)throw i({method:o})}else{if(void 0===r.result)throw i({method:o});const{result:t,transferables:s=[]}=r;e.postMessage({id:n,result:t},s)}}catch(t){const{message:r,status:o=-32603}=t;e.postMessage({error:{code:o,message:r},id:n})}})(e,r);return e.addEventListener(\"message\",n),()=>e.removeEventListener(\"message\",n)},p=e=>e.reduce(((e,t)=>e+t.length),0),m=(e,t)=>{const r=[];let n=0;e:for(;n<t;){const t=e.length;for(let o=0;o<t;o+=1){const t=e[o];void 0===r[o]&&(r[o]=[]);const s=t.shift();if(void 0===s)break e;r[o].push(s),0===o&&(n+=s.length)}}if(n>t){const o=n-t;r.forEach(((t,r)=>{const n=t.pop(),s=n.length-o;t.push(n.subarray(0,s)),e[r].unshift(n.subarray(s))}))}return r},h=new Map,v=(e=>(t,r,n)=>{const o=e.get(t);if(void 0===o){const o={channelDataArrays:n.map((e=>[e])),isComplete:!0,sampleRate:r};return e.set(t,o),o}return o.channelDataArrays.forEach(((e,t)=>e.push(n[t]))),o})(h),g=((e,t)=>(r,n,o,s)=>{const a=o>>3,i=\"subsequent\"===n?0:44,u=r.length,c=e(r[0]),l=new ArrayBuffer(c*u*a+i),d=new DataView(l);return\"subsequent\"!==n&&t(d,o,u,\"complete\"===n?c:Number.POSITIVE_INFINITY,s),r.forEach(((e,t)=>{let r=i+t*a;e.forEach((e=>{const t=e.length;for(let n=0;n<t;n+=1){const t=e[n];d.setInt16(r,t<0?32768*Math.max(-1,t):32767*Math.min(1,t),!0),r+=u*a}}))})),[l]})(p,((e,t,r,n,o)=>{const s=t>>3,a=Math.min(n*r*s,4294967251);e.setUint32(0,1380533830),e.setUint32(4,a+36,!0),e.setUint32(8,1463899717),e.setUint32(12,1718449184),e.setUint32(16,16,!0),e.setUint16(20,1,!0),e.setUint16(22,r,!0),e.setUint32(24,o,!0),e.setUint32(28,o*r*s,!0),e.setUint16(32,r*s,!0),e.setUint16(34,t,!0),e.setUint32(36,1684108385),e.setUint32(40,a,!0)})),x=new Map;f(self,{characterize:()=>({result:/^audio\\\\/wav$/}),encode:e=>{let{recordingId:t,timeslice:r}=e;const n=x.get(t);void 0!==n&&(x.delete(t),n.reject(new Error(\"Another request was made to initiate an encoding.\")));const o=h.get(t);if(null!==r){if(void 0===o||p(o.channelDataArrays[0])*(1e3/o.sampleRate)<r)return new Promise(((e,n)=>{x.set(t,{reject:n,resolve:e,timeslice:r})}));const e=m(o.channelDataArrays,Math.ceil(r*(o.sampleRate/1e3))),n=g(e,o.isComplete?\"initial\":\"subsequent\",16,o.sampleRate);return o.isComplete=!1,{result:n,transferables:n}}if(void 0!==o){const e=g(o.channelDataArrays,o.isComplete?\"complete\":\"subsequent\",16,o.sampleRate);return h.delete(t),{result:e,transferables:e}}return{result:[],transferables:[]}},record:e=>{let{recordingId:t,sampleRate:r,typedArrays:n}=e;const o=v(t,r,n),s=x.get(t);if(void 0!==s&&p(o.channelDataArrays[0])*(1e3/r)>=s.timeslice){const e=m(o.channelDataArrays,Math.ceil(s.timeslice*(r/1e3))),n=g(e,o.isComplete?\"initial\":\"subsequent\",16,r);o.isComplete=!1,x.delete(t),s.resolve({result:n,transferables:n})}return{result:null}}})})()})();`; // tslint:disable-line:max-line-length\n", "import { load } from 'extendable-media-recorder-wav-encoder-broker';\nimport { worker } from './worker/worker';\n\nconst blob: Blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n\nconst url: string = URL.createObjectURL(blob);\n\nconst extendableMediaRecorderWavEncoder = load(url);\n\nexport const characterize = extendableMediaRecorderWavEncoder.characterize;\n\nexport const connect = extendableMediaRecorderWavEncoder.connect;\n\nexport const disconnect = extendableMediaRecorderWavEncoder.disconnect;\n\nexport const encode = extendableMediaRecorderWavEncoder.encode;\n\nexport const isSupported = extendableMediaRecorderWavEncoder.isSupported;\n\nexport const record = extendableMediaRecorderWavEncoder.record;\n\nURL.revokeObjectURL(url);\n", "\uFEFFimport { MediaRecorder, register } from 'extendable-media-recorder';\r\nimport { connect } from 'extendable-media-recorder-wav-encoder';\r\nawait register(await connect());\r\nlet recorder: MediaRecorder | null;\r\nexport interface BrowserMediaDevice {\r\n    DeviceId: string;\r\n    Label: string;\r\n    Kind: string;\r\n    GroupId: string;\r\n}\r\n\r\nexport async function getAudioInputDevices(): Promise<BrowserMediaDevice[]> {\r\n    try {\r\n        const devices: MediaDeviceInfo[] = await navigator.mediaDevices.enumerateDevices();\r\n        return devices.filter((device: MediaDeviceInfo) => device.kind === 'audioinput').map((device: MediaDeviceInfo) => ({\r\n            DeviceId: device.deviceId,\r\n            Label: device.label || 'Unknown Audio Device',\r\n            Kind: device.kind,\r\n            GroupId: device.groupId\r\n        }));\r\n    } catch (error: unknown) {\r\n        console.error('Error fetching audio input devices', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function requestMicrophonePermission(): Promise<boolean> {\r\n    try {\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        return true;\r\n    } catch (error: unknown) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function getSupportedMimeType(): string | null {\r\n    // audio/webm=chrome/edge/firefox, audio/mp4=safari\r\n    const types: string[] = ['audio/wav'];\r\n    for (const type of types) {\r\n        if (MediaRecorder.isTypeSupported(type)) {\r\n            return type;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n// TODO: Fix to reference blazor.d.ts and use DotNet.DotNetObject instead of any for page\r\nexport async function startRecording(page: DotNet.DotNetObject, deviceId: string): Promise<string | null> {\r\n    const mimeType: string | null = getSupportedMimeType();\r\n    if (mimeType) {\r\n        const constraints: MediaStreamConstraints = { audio: { deviceId: deviceId, channelCount: 1 } };\r\n        const options: MediaRecorderOptions = { mimeType: mimeType, audioBitsPerSecond: 16000 };\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n        recorder = new MediaRecorder(stream, options) as MediaRecorder\r\n        let stopped: boolean = false;\r\n        recorder.addEventListener('dataavailable', async (e: BlobEvent) => {\r\n            const buffer: ArrayBuffer = await e.data.arrayBuffer();\r\n            const uint8Array = new Uint8Array(buffer);\r\n            const numericArray = Array.from(uint8Array);\r\n            const binaryString = String.fromCharCode.apply(null, numericArray);\r\n            const base64 = btoa(binaryString);\r\n            await page.invokeMethodAsync(\"DataAvailable\", base64);\r\n            if (stopped) {\r\n                await page.invokeMethodAsync(\"RecordingStopped\");\r\n            }\r\n        });\r\n\r\n        recorder.addEventListener(\"stop\", () => {\r\n            stopped = true;\r\n        });\r\n\r\n        recorder.start(1000);\r\n    } else {\r\n        console.error('No supported audio formats found');\r\n    }\r\n\r\n    return mimeType;\r\n}\r\n\r\n// TODO: Check if mic still hangs open in Mac\r\nexport function stopRecording(): void {\r\n    if (recorder) {\r\n        recorder.stop();\r\n        recorder.stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        recorder = null;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["exports", "createAddUniqueNumber", "generateUniqueNumber", "createCache", "createGenerateUniqueNumber", "cache", "addUniqueNumber", "require_bundle", "exports", "applyModifiers", "buildRegex", "preRenderString", "variable", "compile", "r", "o", "require_bundle", "exports", "createExtendedExponentialRampToValueAutomationEvent", "createExtendedLinearRampToValueAutomationEvent", "createSetValueAutomationEvent", "createSetValueCurveAutomationEvent", "getTargetValueAtTime", "isExponentialRampToValueAutomationEvent", "isLinearRampToValueAutomationEvent", "isAnyRampToValueAutomationEvent", "isSetValueAutomationEvent", "isSetValueCurveAutomationEvent", "getValueOfAutomationEventAtIndexAtTime", "getEndTimeAndValueOfPreviousAutomationEvent", "isCancelAndHoldAutomationEvent", "isCancelScheduledValuesAutomationEvent", "getEventTime", "getExponentialRampValueAtTime", "getLinearRampValueAtTime", "interpolateValue", "getValueCurveValueAtTime", "isSetTargetAutomationEvent", "AutomationEventList", "createCancelAndHoldAutomationEvent", "createCancelScheduledValuesAutomationEvent", "createExponentialRampToValueAutomationEvent", "createLinearRampToValueAutomationEvent", "createSetTargetAutomationEvent", "require_bundle", "exports", "F", "MultiBufferDataView", "buffer", "handler", "import_fast_unique_numbers", "url", "worker", "nativeBlobEventConstructor", "readElementContent", "readElementType", "createEventTarget", "wrapEventListener", "window", "createNotSupportedError", "createWebAudioMediaRecorder", "createWebmPcmMediaRecorder", "encoderRegexes", "eventTargetConstructor", "nativeMediaRecorderConstructor", "window", "window", "createNotSupportedError", "nativeMediaRecorderConstructor", "readVariableSizeInteger", "readVariableSizeInteger", "readVariableSizeIntegerLength", "import_fast_unique_numbers", "emitNotSupportedError", "window", "wrapSubscribeFunction", "mapSubscribableThing", "mutations", "prependSubscribableThing", "emitNotSupportedError", "window", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "mediaDevices", "emitNotSupportedError", "window", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "wrapSubscribeFunction", "midiInputs", "wrapSubscribeFunction", "midiOutputs", "emitNotSupportedError", "window", "wrapSubscribeFunction", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "emitNotSupportedError", "wrapSubscribeFunction", "emitNotSupportedError", "window", "wrapSubscribeFunction", "patch", "toObserver", "window", "import_fast_unique_numbers", "worklet", "addAudioWorkletModule", "blob", "url", "generateUniqueNumber", "createListener", "on", "validateState", "audioWorkletNodeConstructor", "import_automation_events", "insertElementInSet", "url", "cacheTestResult", "createNotSupportedError", "exposeCurrentFrameAndCurrentTime", "getNativeContext", "getOrCreateBackupOfflineAudioContext", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "window", "blob", "url", "addActiveInputConnectionToAudioNode", "addPassiveInputConnectionToAudioNode", "connectNativeAudioNodeToNativeAudioNode", "deleteActiveInputConnectionToAudioNode", "disconnectNativeAudioNodeFromNativeAudioNode", "getAudioNodeConnections", "getAudioNodeTailTime", "getEventListenersOfAudioNode", "getNativeAudioNode", "insertElementInSet", "isActiveAudioNode", "isPartOfACycle", "isPassiveAudioNode", "insertElementInSet", "createNativeGainNode", "disconnect", "getUnrenderedAudioWorkletNodes", "createAnalyserNodeRenderer", "createIndexSizeError", "createNativeAnalyserNode", "getNativeContext", "isNativeOfflineAudioContext", "createNativeAnalyserNode", "getNativeAudioNode", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioBufferStore", "cacheTestResult", "createNotSupportedError", "nativeAudioBufferConstructor", "nativeOfflineAudioContextConstructor", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioBufferSourceNodeRenderer", "createAudioParam", "createInvalidStateError", "createNativeAudioBufferSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "connectAudioParam", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "baseAudioContextConstructor", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "mediaElementAudioSourceNodeConstructor", "mediaStreamAudioDestinationNodeConstructor", "mediaStreamAudioSourceNodeConstructor", "mediaStreamTrackAudioSourceNodeConstructor", "nativeAudioContextConstructor", "audioNodeConstructor", "createAudioDestinationNodeRenderer", "createIndexSizeError", "createInvalidStateError", "getNativeContext", "isNativeOfflineAudioContext", "renderInputsOfAudioNode", "renderInputsOfAudioNode", "createAudioParam", "createNativeChannelMergerNode", "createNativeConstantSourceNode", "createNativeScriptProcessorNode", "createNotSupportedError", "getFirstSample", "isNativeOfflineAudioContext", "overwriteAccessors", "nativeAudioWorkletNodeConstructor", "connect", "disconnect", "cacheTestResult", "createIndexSizeError", "createInvalidAccessError", "createNotSupportedError", "eventTargetConstructor", "getNativeContext", "isNativeAudioContext", "isNativeAudioNode", "isNativeAudioParam", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "audioParamAudioNodeStore", "createAudioParamRenderer", "createCancelAndHoldAutomationEvent", "createCancelScheduledValuesAutomationEvent", "createExponentialRampToValueAutomationEvent", "createLinearRampToValueAutomationEvent", "createSetTargetAutomationEvent", "createSetValueAutomationEvent", "createSetValueCurveAutomationEvent", "nativeAudioContextConstructor", "setValueAtTimeUntilPossible", "DEFAULT_OPTIONS", "addUnrenderedAudioWorkletNode", "audioNodeConstructor", "createAudioParam", "createAudioWorkletNodeRenderer", "createNativeAudioWorkletNode", "getAudioNodeConnections", "getBackupOfflineAudioContext", "getNativeContext", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "sanitizeAudioWorkletNodeOptions", "setActiveAudioWorkletNodeInputs", "testAudioWorkletNodeOptionsClonability", "wrapEventListener", "exposeCurrentFrameAndCurrentTime", "connectAudioParam", "connectMultipleOutputs", "createNativeAudioBufferSourceNode", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "deleteUnrenderedAudioWorkletNode", "disconnectMultipleOutputs", "getNativeAudioNode", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "addAudioWorkletModule", "analyserNodeConstructor", "audioBufferConstructor", "audioBufferSourceNodeConstructor", "biquadFilterNodeConstructor", "channelMergerNodeConstructor", "channelSplitterNodeConstructor", "constantSourceNodeConstructor", "convolverNodeConstructor", "decodeAudioData", "delayNodeConstructor", "dynamicsCompressorNodeConstructor", "gainNodeConstructor", "iIRFilterNodeConstructor", "minimalBaseAudioContextConstructor", "oscillatorNodeConstructor", "pannerNodeConstructor", "periodicWaveConstructor", "stereoPannerNodeConstructor", "waveShaperNodeConstructor", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createBiquadFilterNodeRenderer", "createInvalidAccessError", "createNativeBiquadFilterNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "connectAudioParam", "createNativeBiquadFilterNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createChannelMergerNodeRenderer", "createNativeChannelMergerNode", "getNativeContext", "isNativeOfflineAudioContext", "createNativeChannelMergerNode", "getNativeAudioNode", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createChannelSplitterNodeRenderer", "createNativeChannelSplitterNode", "getNativeContext", "isNativeOfflineAudioContext", "sanitizeChannelSplitterOptions", "createNativeChannelSplitterNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderInputsOfAudioParam", "createIndexSizeError", "createNativeAudioBufferSourceNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createConstantSourceNodeRendererFactory", "createNativeConstantSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "connectAudioParam", "createNativeConstantSourceNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createConvolverNodeRenderer", "createNativeConvolverNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "createNativeConvolverNode", "getNativeAudioNode", "renderInputsOfAudioNode", "createNotSupportedError", "nativeOfflineAudioContextConstructor", "audioBufferStore", "cacheTestResult", "createDataCloneError", "createEncodingError", "getNativeContext", "isNativeContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "testPromiseSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "connectNativeAudioNodeToNativeAudioNode", "getAudioNodeConnections", "getNativeAudioNode", "getNativeAudioParam", "getNativeContext", "isActiveAudioNode", "isNativeOfflineAudioContext", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createDelayNodeRenderer", "createNativeDelayNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "connectAudioParam", "createNativeDelayNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "pickElementFromSet", "getUnrenderedAudioWorkletNodes", "audioParamAudioNodeStore", "getAudioNodeConnections", "getValueForKey", "createIndexSizeError", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createDynamicsCompressorNodeRenderer", "createNativeDynamicsCompressorNode", "createNotSupportedError", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "connectAudioParam", "createNativeDynamicsCompressorNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "window", "blob", "url", "createEventTargetConstructor", "wrapEventListener", "window", "createAbortError", "url", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createGainNodeRenderer", "createNativeGainNode", "getNativeContext", "isNativeOfflineAudioContext", "connectAudioParam", "createNativeGainNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "activeAudioWorkletNodeInputsStore", "getValueForKey", "getAudioNodeConnections", "audioNodeTailTimeStore", "getAudioParamConnections", "backupOfflineAudioContextStore", "createInvalidStateError", "createInvalidStateError", "backupOfflineAudioContextStore", "nativeOfflineAudioContextConstructor", "unrenderedAudioWorkletNodeStore", "DEFAULT_OPTIONS", "audioNodeConstructor", "createNativeIIRFilterNode", "createIIRFilterNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "nativeOfflineAudioContextConstructor", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "disconnectNativeAudioNodeFromNativeAudioNode", "getAudioNodeConnections", "getNativeAudioNode", "getNativeAudioParam", "isActiveAudioNode", "isNativeAudioContext", "isNativeAudioNode", "isNativeAudioParam", "isNativeOfflineAudioContext", "nativeAudioContextConstructor", "window", "window", "isNativeAudioContext", "isNativeOfflineAudioContext", "nativeOfflineAudioContextConstructor", "window", "audioNodeConstructor", "createNativeMediaElementAudioSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "DEFAULT_OPTIONS", "audioNodeConstructor", "createNativeMediaStreamAudioDestinationNode", "getNativeContext", "isNativeOfflineAudioContext", "audioNodeConstructor", "createNativeMediaStreamAudioSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "audioNodeConstructor", "createNativeMediaStreamTrackAudioSourceNode", "getNativeContext", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "minimalBaseAudioContextConstructor", "nativeAudioContextConstructor", "audioDestinationNodeConstructor", "createAudioListener", "eventTargetConstructor", "isNativeOfflineAudioContext", "unrenderedAudioWorkletNodeStore", "wrapEventListener", "DEFAULT_OPTIONS", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "minimalBaseAudioContextConstructor", "startRendering", "insertElementInSet", "isNativeAudioNode", "connect", "disconnect", "cacheTestResult", "createIndexSizeError", "window", "createInvalidStateError", "addSilentConnection", "cacheTestResult", "testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport", "testAudioBufferSourceNodeStartMethodOffsetClampingSupport", "testAudioBufferSourceNodeStopMethodNullifiedBufferSupport", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "window", "createNativeGainNode", "overwriteAccessors", "window", "createInvalidStateError", "createNativeAudioWorkletNodeFaker", "createNativeGainNode", "createNotSupportedError", "monitorConnections", "nativeAudioWorkletNodeConstructor", "connectMultipleOutputs", "createIndexSizeError", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNotSupportedError", "disconnectMultipleOutputs", "exposeCurrentFrameAndCurrentTime", "getActiveAudioWorkletNodeInputs", "monitorConnections", "nativeAudioContextConstructor", "wrapChannelMergerNode", "createInvalidStateError", "addSilentConnection", "cacheTestResult", "createNativeConstantSourceNodeFaker", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "addSilentConnection", "createNativeAudioBufferSourceNode", "createNativeGainNode", "monitorConnections", "createNotSupportedError", "overwriteAccessors", "createNotSupportedError", "createNativeIIRFilterNodeFaker", "createInvalidAccessError", "createInvalidStateError", "createNativeScriptProcessorNode", "createNotSupportedError", "createInvalidStateError", "isNativeOfflineAudioContext", "window", "addSilentConnection", "cacheTestResult", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "createNativePannerNodeFaker", "connectNativeAudioNodeToNativeAudioNode", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNativeWaveShaperNode", "createNotSupportedError", "disconnectNativeAudioNodeFromNativeAudioNode", "getFirstSample", "monitorConnections", "createIndexSizeError", "createNotSupportedError", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeGainNode", "createNativeWaveShaperNode", "createNotSupportedError", "monitorConnections", "nativeStereoPannerNodeFakerFactory", "createConnectedNativeAudioBufferSourceNode", "createInvalidStateError", "createNativeWaveShaperNodeFaker", "isDCCurve", "monitorConnections", "nativeAudioContextConstructor", "overwriteAccessors", "createConnectedNativeAudioBufferSourceNode", "createInvalidStateError", "createNativeGainNode", "isDCCurve", "monitorConnections", "createNotSupportedError", "DEFAULT_OPTIONS", "baseAudioContextConstructor", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "startRendering", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createNativeOscillatorNode", "createOscillatorNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "connectAudioParam", "createNativeOscillatorNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createNativePannerNode", "createPannerNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "connectAudioParam", "createNativeChannelMergerNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativePannerNode", "getNativeAudioNode", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "DEFAULT_OPTIONS", "createNativePeriodicWave", "getNativeContext", "sanitizePeriodicWaveOptions", "renderInputsOfAudioParam", "getAudioNodeConnections", "getAudioNodeRenderer", "isPartOfACycle", "getAudioNodeRenderer", "getAudioParamConnections", "isPartOfACycle", "cacheTestResult", "createNativeGainNode", "createNativeScriptProcessorNode", "activeAudioWorkletNodeInputsStore", "audioNodeTailTimeStore", "audioBufferStore", "cacheTestResult", "getAudioNodeRenderer", "getUnrenderedAudioWorkletNodes", "renderNativeOfflineAudioContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createNativeStereoPannerNode", "createStereoPannerNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "connectAudioParam", "createNativeStereoPannerNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "nativeAudioBufferConstructor", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "blob", "url", "createNativeGainNode", "nativeOfflineAudioContextConstructor", "DEFAULT_OPTIONS", "audioNodeConstructor", "createInvalidStateError", "createNativeWaveShaperNode", "createWaveShaperNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "createNativeWaveShaperNode", "getNativeAudioNode", "renderInputsOfAudioNode", "createWindow", "convertNumberToUnsignedLong", "createIndexSizeError", "convertNumberToUnsignedLong", "copyFromChannel", "copyToChannel", "overwriteAccessors", "createInvalidStateError", "monitorConnections", "disconnect", "window", "createWindow", "createEventTargetConstructor", "isNativeAudioNode", "createNotSupportedError", "window", "createNotSupportedError", "createInvalidStateError", "createInvalidStateError", "isNativeAudioNode", "createNotSupportedError", "window", "createInvalidStateError", "createNotSupportedError", "createInvalidStateError", "createNotSupportedError", "createNotSupportedError", "createInvalidStateError", "createInvalidStateError", "isNativeAudioNode", "createBlobEvent", "createInvalidModificationError", "createInvalidStateError", "createNotSupportedError", "url", "_a", "createBlobEvent", "decodeWebMChunk", "readVariableSizeInteger", "nativeMediaRecorderConstructor", "stopRecording", "createWindow", "wrapEventListener", "window", "createWindow", "wrapEventListener", "register", "wrap", "load", "url", "worker", "worker", "blob", "worker", "url", "load", "connect", "disconnect", "encode", "isSupported", "register", "connect"]
}
