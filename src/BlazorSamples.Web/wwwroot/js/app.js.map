{
  "version": 3,
  "sources": ["../../scripts/app.ts"],
  "sourcesContent": ["\uFEFF//import { MediaRecorder, register } from 'extendable-media-recorder';\r\n//import { connect } from 'extendable-media-recorder-wav-encoder';\r\n//await register(await connect());\r\nlet recorder: MediaRecorder | null;\r\nexport interface BrowserMediaDevice {\r\n    DeviceId: string;\r\n    Label: string;\r\n    Kind: string;\r\n    GroupId: string;\r\n}\r\n\r\nexport async function getAudioInputDevices(): Promise<BrowserMediaDevice[]> {\r\n    try {\r\n        const devices: MediaDeviceInfo[] = await navigator.mediaDevices.enumerateDevices();\r\n        return devices.filter((device: MediaDeviceInfo) => device.kind === 'audioinput').map((device: MediaDeviceInfo) => ({\r\n            DeviceId: device.deviceId,\r\n            Label: device.label || 'Unknown Audio Device',\r\n            Kind: device.kind,\r\n            GroupId: device.groupId\r\n        }));\r\n    } catch (error: unknown) {\r\n        console.error('Error fetching audio input devices', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function requestMicrophonePermission(): Promise<boolean> {\r\n    try {\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        return true;\r\n    } catch (error: unknown) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function getSupportedMimeType(): string | null {\r\n    // audio/webm=chrome/edge/firefox, audio/mp4=safari\r\n    //const types: string[] = ['audio/wav'];\r\n    const types: string[] = ['audio/webm', 'audio/mp4'];\r\n    for (const type of types) {\r\n        if (MediaRecorder.isTypeSupported(type)) {\r\n            return type;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport async function startRecording(page: DotNet.DotNetObject, deviceId: string): Promise<string | null> {\r\n    const mimeType: string | null = getSupportedMimeType();\r\n    if (mimeType) {\r\n        const constraints: MediaStreamConstraints = { audio: { deviceId: deviceId, channelCount: 1 } };\r\n        const options: MediaRecorderOptions = { mimeType: mimeType, audioBitsPerSecond: 16000 };\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n        recorder = new MediaRecorder(stream, options) as MediaRecorder\r\n        let stopped: boolean = false;\r\n        recorder.addEventListener('dataavailable', async (e: BlobEvent) => {\r\n            // TODO: Figure out TextDecoder\r\n            // https://learn.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/call-javascript-from-dotnet?view=aspnetcore-8.0#javascript-isolation-in-javascript-modules\r\n            // const decoder = new TextDecoder();\r\n            const buffer: ArrayBuffer = await e.data.arrayBuffer();\r\n            const uint8Array: Uint8Array = new Uint8Array(buffer);\r\n            // TODO: Fix this hack uint8Array as unknown as number[]\r\n            const binaryString = String.fromCharCode.apply(null, uint8Array as unknown as number[]);\r\n            const base64 = btoa(binaryString);\r\n            await page.invokeMethodAsync(\"DataAvailable\", base64);\r\n            if (stopped) {\r\n                await page.invokeMethodAsync(\"RecordingStopped\");\r\n            }\r\n        });\r\n\r\n        recorder.addEventListener(\"stop\", () => {\r\n            stopped = true;\r\n        });\r\n\r\n        recorder.start(1000);\r\n    } else {\r\n        console.error('No supported audio formats found');\r\n    }\r\n\r\n    return mimeType;\r\n}\r\n\r\n// TODO: Check if mic still hangs open in Mac\r\nexport function stopRecording(): void {\r\n    if (recorder) {\r\n        recorder.stop();\r\n        recorder.stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        recorder = null;\r\n    }\r\n}\r\n"],
  "mappings": ";AAGA,IAAI;AAQJ,eAAsB,uBAAsD;AACxE,MAAI;AACA,UAAM,UAA6B,MAAM,UAAU,aAAa,iBAAiB;AACjF,WAAO,QAAQ,OAAO,CAAC,WAA4B,OAAO,SAAS,YAAY,EAAE,IAAI,CAAC,YAA6B;AAAA,MAC/G,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO,SAAS;AAAA,MACvB,MAAM,OAAO;AAAA,MACb,SAAS,OAAO;AAAA,IACpB,EAAE;AAAA,EACN,SAAS,OAAgB;AACrB,YAAQ,MAAM,sCAAsC,KAAK;AACzD,WAAO,CAAC;AAAA,EACZ;AACJ;AAEA,eAAsB,8BAAgD;AAClE,MAAI;AACA,UAAM,SAAsB,MAAM,UAAU,aAAa,aAAa,EAAE,OAAO,KAAK,CAAC;AACrF,WAAO,UAAU,EAAE,QAAQ,CAAC,UAA4B,MAAM,KAAK,CAAC;AACpE,WAAO;AAAA,EACX,SAAS,OAAgB;AACrB,WAAO;AAAA,EACX;AACJ;AAEO,SAAS,uBAAsC;AAGlD,QAAM,QAAkB,CAAC,cAAc,WAAW;AAClD,aAAW,QAAQ,OAAO;AACtB,QAAI,cAAc,gBAAgB,IAAI,GAAG;AACrC,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,SAAO;AACX;AAEA,eAAsB,eAAe,MAA2B,UAA0C;AACtG,QAAM,WAA0B,qBAAqB;AACrD,MAAI,UAAU;AACV,UAAM,cAAsC,EAAE,OAAO,EAAE,UAAoB,cAAc,EAAE,EAAE;AAC7F,UAAM,UAAgC,EAAE,UAAoB,oBAAoB,KAAM;AACtF,UAAM,SAAsB,MAAM,UAAU,aAAa,aAAa,WAAW;AACjF,eAAW,IAAI,cAAc,QAAQ,OAAO;AAC5C,QAAI,UAAmB;AACvB,aAAS,iBAAiB,iBAAiB,OAAO,MAAiB;AAI/D,YAAM,SAAsB,MAAM,EAAE,KAAK,YAAY;AACrD,YAAM,aAAyB,IAAI,WAAW,MAAM;AAEpD,YAAM,eAAe,OAAO,aAAa,MAAM,MAAM,UAAiC;AACtF,YAAM,SAAS,KAAK,YAAY;AAChC,YAAM,KAAK,kBAAkB,iBAAiB,MAAM;AACpD,UAAI,SAAS;AACT,cAAM,KAAK,kBAAkB,kBAAkB;AAAA,MACnD;AAAA,IACJ,CAAC;AAED,aAAS,iBAAiB,QAAQ,MAAM;AACpC,gBAAU;AAAA,IACd,CAAC;AAED,aAAS,MAAM,GAAI;AAAA,EACvB,OAAO;AACH,YAAQ,MAAM,kCAAkC;AAAA,EACpD;AAEA,SAAO;AACX;AAGO,SAAS,gBAAsB;AAClC,MAAI,UAAU;AACV,aAAS,KAAK;AACd,aAAS,OAAO,UAAU,EAAE,QAAQ,CAAC,UAA4B,MAAM,KAAK,CAAC;AAC7E,eAAW;AAAA,EACf;AACJ;",
  "names": []
}
