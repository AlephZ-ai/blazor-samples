{
  "version": 3,
  "sources": ["../../scripts/app.ts"],
  "sourcesContent": ["\uFEFF//import { MediaRecorder, register } from 'extendable-media-recorder';\r\n//import { connect } from 'extendable-media-recorder-wav-encoder';\r\n//await register(await connect());\r\nimport audioBufferToWav from 'audiobuffer-to-wav';\r\nlet recorder: MediaRecorder | null;\r\nexport interface BrowserMediaDevice {\r\n    DeviceId: string;\r\n    Label: string;\r\n    Kind: string;\r\n    GroupId: string;\r\n}\r\n\r\nexport async function getAudioInputDevices(): Promise<BrowserMediaDevice[]> {\r\n    try {\r\n        const devices: MediaDeviceInfo[] = await navigator.mediaDevices.enumerateDevices();\r\n        return devices.filter((device: MediaDeviceInfo) => device.kind === 'audioinput').map((device: MediaDeviceInfo) => ({\r\n            DeviceId: device.deviceId,\r\n            Label: device.label || 'Unknown Audio Device',\r\n            Kind: device.kind,\r\n            GroupId: device.groupId\r\n        }));\r\n    } catch (error: unknown) {\r\n        console.error('Error fetching audio input devices', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport async function requestMicrophonePermission(): Promise<boolean> {\r\n    try {\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        return true;\r\n    } catch (error: unknown) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function getSupportedMimeType(): string | null {\r\n    // audio/webm=chrome/edge/firefox, audio/mp4=safari\r\n    //const types: string[] = ['audio/wav'];\r\n    const types: string[] = ['audio/webm', 'audio/mp4'];\r\n    for (const type of types) {\r\n        if (MediaRecorder.isTypeSupported(type)) {\r\n            return type;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport async function startRecording(page: DotNet.DotNetObject, deviceId: string): Promise<string | null> {\r\n    let mimeType: string | null = getSupportedMimeType();\r\n    if (mimeType) {\r\n        const constraints: MediaStreamConstraints = { audio: { deviceId: deviceId } };\r\n        const options: MediaRecorderOptions = { mimeType: mimeType };\r\n        const stream: MediaStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n        recorder = new MediaRecorder(stream, options);\r\n        mimeType = recorder.mimeType;\r\n        const track: MediaStreamTrack = stream.getAudioTracks()[0];\r\n        const settings: MediaTrackSettings = track.getSettings();\r\n        const { channelCount, sampleRate }: MediaTrackSettings = settings;\r\n        console.log(recorder);\r\n        console.log(stream);\r\n        console.log(track);\r\n        console.log(settings);\r\n        let stopped: boolean = false;\r\n        recorder.ondataavailable = async (e: BlobEvent) => {\r\n            const data: ArrayBuffer = await e.data.arrayBuffer();\r\n            const uint8Array: Uint8Array = new Uint8Array(data);\r\n            await page.invokeMethodAsync(\"DataAvailable\", uint8Array, mimeType);\r\n            if (stopped) {\r\n                await page.invokeMethodAsync(\"RecordingStopped\");\r\n            }\r\n        };\r\n\r\n        recorder.onstop = () => {\r\n            stopped = true;\r\n        };\r\n\r\n        recorder.start(500);\r\n    } else {\r\n        console.error('No supported audio formats found');\r\n    }\r\n\r\n    return mimeType;\r\n}\r\n\r\nexport function stopRecording(): void {\r\n    if (recorder) {\r\n        recorder.stop();\r\n        recorder.stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\r\n        recorder = null;\r\n    }\r\n}\r\n"],
  "mappings": ";AAIA,IAAI;AAQJ,eAAsB,uBAAsD;AACxE,MAAI;AACA,UAAM,UAA6B,MAAM,UAAU,aAAa,iBAAiB;AACjF,WAAO,QAAQ,OAAO,CAAC,WAA4B,OAAO,SAAS,YAAY,EAAE,IAAI,CAAC,YAA6B;AAAA,MAC/G,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO,SAAS;AAAA,MACvB,MAAM,OAAO;AAAA,MACb,SAAS,OAAO;AAAA,IACpB,EAAE;AAAA,EACN,SAAS,OAAgB;AACrB,YAAQ,MAAM,sCAAsC,KAAK;AACzD,WAAO,CAAC;AAAA,EACZ;AACJ;AAEA,eAAsB,8BAAgD;AAClE,MAAI;AACA,UAAM,SAAsB,MAAM,UAAU,aAAa,aAAa,EAAE,OAAO,KAAK,CAAC;AACrF,WAAO,UAAU,EAAE,QAAQ,CAAC,UAA4B,MAAM,KAAK,CAAC;AACpE,WAAO;AAAA,EACX,SAAS,OAAgB;AACrB,WAAO;AAAA,EACX;AACJ;AAEO,SAAS,uBAAsC;AAGlD,QAAM,QAAkB,CAAC,cAAc,WAAW;AAClD,aAAW,QAAQ,OAAO;AACtB,QAAI,cAAc,gBAAgB,IAAI,GAAG;AACrC,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,SAAO;AACX;AAEA,eAAsB,eAAe,MAA2B,UAA0C;AACtG,MAAI,WAA0B,qBAAqB;AACnD,MAAI,UAAU;AACV,UAAM,cAAsC,EAAE,OAAO,EAAE,SAAmB,EAAE;AAC5E,UAAM,UAAgC,EAAE,SAAmB;AAC3D,UAAM,SAAsB,MAAM,UAAU,aAAa,aAAa,WAAW;AACjF,eAAW,IAAI,cAAc,QAAQ,OAAO;AAC5C,eAAW,SAAS;AACpB,UAAM,QAA0B,OAAO,eAAe,EAAE,CAAC;AACzD,UAAM,WAA+B,MAAM,YAAY;AACvD,UAAM,EAAE,cAAc,WAAW,IAAwB;AACzD,YAAQ,IAAI,QAAQ;AACpB,YAAQ,IAAI,MAAM;AAClB,YAAQ,IAAI,KAAK;AACjB,YAAQ,IAAI,QAAQ;AACpB,QAAI,UAAmB;AACvB,aAAS,kBAAkB,OAAO,MAAiB;AAC/C,YAAM,OAAoB,MAAM,EAAE,KAAK,YAAY;AACnD,YAAM,aAAyB,IAAI,WAAW,IAAI;AAClD,YAAM,KAAK,kBAAkB,iBAAiB,YAAY,QAAQ;AAClE,UAAI,SAAS;AACT,cAAM,KAAK,kBAAkB,kBAAkB;AAAA,MACnD;AAAA,IACJ;AAEA,aAAS,SAAS,MAAM;AACpB,gBAAU;AAAA,IACd;AAEA,aAAS,MAAM,GAAG;AAAA,EACtB,OAAO;AACH,YAAQ,MAAM,kCAAkC;AAAA,EACpD;AAEA,SAAO;AACX;AAEO,SAAS,gBAAsB;AAClC,MAAI,UAAU;AACV,aAAS,KAAK;AACd,aAAS,OAAO,UAAU,EAAE,QAAQ,CAAC,UAA4B,MAAM,KAAK,CAAC;AAC7E,eAAW;AAAA,EACf;AACJ;",
  "names": []
}
